{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"欢迎大家!!","date":"2019-05-24T09:29:49.538Z","updated":"2019-05-24T09:29:49.538Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"真正的才智是刚毅的志向。 —— 拿破仑感情有着极大的鼓舞力量，因此，它是一切道德行为的重要前提，谁要是没有强烈的志向，也就不能够热烈地把这个志向体现于事业中。 —— 凯洛夫勇敢坚毅真正之才智乃刚毅之志向。 —— 拿破仑生活赋予我们一种巨大的和无限高贵的礼品，这就是青春：充满着力量，充满着期待志愿，充满着求知和斗争的志向，充满着希望信心和青春。 —— 奥斯特洛夫斯基志向不过是记忆的奴隶，生气勃勃地降生，但却很难成长。 —— 莎士比亚"}],"posts":[{"title":"计算机网络笔记","slug":"网络","date":"2019-06-29T05:46:16.000Z","updated":"2019-07-08T07:20:37.590Z","comments":true,"path":"2019/06/29/网络/","link":"","permalink":"http://yoursite.com/2019/06/29/网络/","excerpt":"","text":"分层体系:OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类 A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）； B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） 网络设备 假设一集线器存在７个端口，共连接了５台计算机，那么该网络环境中存在冲突域的个数为（1）？ 集线器的所有端口是一个冲突域，交换机的每个端口是一个冲突域，注意这两个不一样 交换机工作于OSI参考模型的第二层,被广泛应用于二层网络交换，俗称“二层交换机”。 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的 第二层、第三层、第四层和第七层，并因此而得名。 工作原理:交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上， 当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡） 挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口， 接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中。 特点:1.独享宽带. 2.全双工. 路由器工作在OSI模型的第三层——即网络层.它根据ＩＰ地址进行寻址，通过路由表路由协议产生。 路由器的两个主要作用 1.连通不同的网络，2.选择信息传送的线路。 网关（Gateway）网络层以上的设备.网关顾名思义就是连接两个网络的设备 网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据， 而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 socket编程，服务器端和客户端各个函数 服务器端：socket(), bind(), listen(), accept(),….close(), 客户端：socket(), connect(),close()等等 JAVA Socket 编程学习笔记 电路交换的三个阶段： （1）建立连接 （2）通信 （3）释放连接 电路交换具有以下优缺点： 优点： （1）由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。 （2）通信双方之间的屋里通路一旦建立，双方可以随时通信，实时性强。 （3）双方通信时按发送顺序传送数据，不存在失序问题。 （4）电路交换既适用于传输模拟信号，也适用于传输数字信号。 （5）电路交换的交换设备及控制均比较简单。 缺点： （1）电路交换平均连接建立时间对计算机通信来说较长。 （2）电路交换家里连接后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低。 （3）电路交换时，数据直达，不同类型，不同规格，不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。分组交换 分组交换是以分组为单位进行传输和交换的，它是一种存储——转发交换方式，即将到达交换机的分组先送到存储器暂时存储和处理，等到相应的输出电路有空闲时再送出。 分组交换具有以下优缺点。 优点： （1）分组交换不需要为通信双反预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组。 （2）由于采用存储转发方式，加之交换节点具有路径选择，当某条传输线路故障时可选择其他传输线路，提高了传输的可靠性。 （3）通信双反不是固定的战友一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。 （4）加速了数据在网络中的传输。因而分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了传输时间。 （5）分组长度固定，相应的缓冲区的大小也固定，所以简化了交换节点中存储器的管理。 （6）分组较短，出错几率减少，每次重发的数据量也减少，不仅提高了可靠性，也减少了时延。 缺点： （1）由于数据进入交换节点后要经历存储转发这一过程，从而引起的转发时延（包括接受分组、检验正确性、排队、发送时间等），而且网络的通信量越大，造成的时延就越大，实时性较差。 （2）分组交换只适用于数字信号。 （3）分组交换可能出现失序，丢失或重复分组，分组到达目的节点时，对分组按编号进行排序等工作，增加了麻烦。 综上，若传输的数据量很大，而且传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段链路组， 则采用分组交换 上网的时候发现网页不能访问,QQ使用正常,出现此问题最可能的原因是 DNS 网络层 1.常见的路由选择协议，以及它们的区别 OSPF(Open Shortest Path First开放式最短路径优先)使用链路状态协议， RIP（Routing information Protocol，路由信息协议）使用距离向量协议（1）当链路变化时，OSPF向本自治系统所有路由器发出信息，即洪泛法。而RIP只向相邻路由器发送（2）OSPF发送的信息是与本路由器相连的所有链路状态，而RIP只发送到所有网络的距离和下一跳的路由器（3）只有链路状态变化时，OSPF才发送信息。而RIP会定期与周围路由器交换信息 2.ARP是地址解析协议，简单语言解释一下工作原理。1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址， 如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包， 该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址， 如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中， 如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。 如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 RARP Reverse Address Resolution Protocol是逆地址解析协议 作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后， 就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后， 就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文， 因此RARP只能用于具有广播能力的网络。 3.ICMP是（Internet Control Message Protocol）Internet控制报文协议。 它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、 路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用. 4.DHCP（Dynamic Host Configuration Protocol，动态主机配置协议） 是一个局域网的网络协议，使用UDP协议工作， 主要有两个用途：给内部网络或网络服务供应商自动分配IP地址， 给用户或者内部网络管理员作为对所有计算机作中央管理的手段， 5.NAT（Network Address Translation，网络地址转换） 是将IP数据报头中的IP地址转换为另一个IP地址的过程。在实际应用中，NAT主要用于实现私有网络访问公共网络的功能。 这种通过使用少量的公网IP地址代表较多的私网IP地址的方式，将有助于减缓可用IP地址空间的枯竭。 6.IP(网络之间互连的协议 Internet Protocol) 是用于将多个包交换网络连接起来的，它在源地址和目的地址之间传送一种称之为数据包的东西， 它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。 传输层 1.tcp协议和udp协议的差别 TCP UDP传输单位 报文段 用户数据报 是否连接 面向连接 面向非连接传输可靠性 可靠 不可靠应用场合 传输大量数据 少量数据速度 慢 快 2.TCP的可靠性如何保证： 在TCP的连接中，数据流必须以正确的顺序送达对方。TCP的可靠性是通过顺序编号和确认（ACK）来实现的。 TCP在开始传送一个段时，为准备重传而首先将该段插入到发送队列之中，同时启动时钟。 其后，如果收到了接受端对该段的ACK信息，就将该段从队列中删去。 如果在时钟规定的时间内，ACK未返回，那么就从发送队列中再次送出这个段。 TCP在协议中就对数据可靠传输做了保障，握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则；而UDP主要是面向不可靠连接的，不能保证数据正确到达目的地。 3.TCP三次握手和四次挥手的全过程 三次握手： 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y) 即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕， 客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下， TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方： 我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文， 主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方， 我的数据也发送完了，不会再给你发数据了。第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 CLOSED：初始状态，表示没有任何连接。LISTEN：Server端的某个Socket正在监听来自远方的TCP端口的连接请求。SYN_SENT：发送连接请求后等待确认信息。当客户端Socket进行Connect连接时，会首先发送SYN包， 随即进入SYN_SENT状态，然后等待Server端发送三次握手中的第2个包。SYN_RECEIVED：收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。通常是建立TCP连接的 三次握手过程中的一个中间状态，表示Server端的Socket接收到来自Client的SYN包，并作出回应。ESTABLISHED：表示连接已经建立，可以进行数据传输。FIN_WAIT_1：主动关闭连接的一方等待对方返回ACK包。若Socket在ESTABLISHED状态下主动关闭连接并向对方发送FIN包（表示己方不再有数据需要发送），则进入FIN_WAIT_1状态，等待对方返回ACK包，此后还能读取数据，但不能发送数据。在正常情况下，无论对方处于何种状态，都应该马上返回ACK包，所以FIN_WAIT_1状态一般很难见到。FIN_WAIT_2：主动关闭连接的一方收到对方返回的ACK包后，等待对方发送FIN包。处于FIN_WAIT_1状态下的Socket收到了对方返回的ACK包后，便进入FIN_WAIT_2状态。由于FIN_WAIT_2状态下的Socket需要等待对方发送的FIN包，所有常常可以看到。若在FIN_WAIT_1状态下收到对方发送的同时带有FIN和ACK的包时，则直接进入TIME_WAIT状态，无须经过FIN_WAIT_2状态。TIME_WAIT：主动关闭连接的一方收到对方发送的FIN包后返回ACK包（表示对方也不再有数据需要发送，此后不能再读取或发送数据），然后等待足够长的时间（2MSL）以确保对方接收到ACK包（考虑到丢失ACK包的可能和迷路重复数据包的影响），最后回到CLOSED状态，释放网络资源。CLOSE_WAIT：表示被动关闭连接的一方在等待关闭连接。当收到对方发送的FIN包后（表示对方不再有数据需要发送），相应的返回ACK包，然后进入CLOSE_WAIT状态。在该状态下，若己方还有数据未发送，则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。LAST_ACK：被动关闭连接的一方在CLOSE_WAIT状态下完成数据的发送后便可向对方发送FIN包（表示己方不再有数据需要发送），然后等待对方返回ACK包。收到ACK包后便回到CLOSED状态，释放网络资源。CLOSING：比较罕见的例外状态。正常情况下，发送FIN包后应该先收到（或同时收到）对方的ACK包，再收到对方的FIN包，而CLOSING状态表示发送FIN包后并没有收到对方的ACK包，却已收到了对方的FIN包。有两种情况可能导致这种状态：其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送FIN包的情况；其二，如果ACK包丢失而对方的FIN包很快发出，也会出现FIN先于ACK到达。 4.为什么不能采用两次握手: 采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 应用层 UDP对应的协议： 1.TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间 进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。 2.DNS协议：域名系统 (Domain Name System)，是因特网的一项核心服务，它作为可以将域名和IP地址 相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 比如百度的一台服务器的IP地址为115.239.210.27，我们在浏览器中输入http://115.239.210.27/就可以访问百度了， 但是如果访问一个网站就要记住它的的IP是很蛋疼的事，人们习惯记住有意义的字符串，比如baidu。 3.SNMP(Simple Network Management Protocol,简单网络管理协议)是用来管理网络设备的。 由于网络设备很多，无连接的服务就体现出其优势。 TCP对应的协议：1.HTTP(Hyper Text Transfer Protocol超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。 http请求由三部分组成，分别是：请求行、消息报头、请求正文 常用的HTTP方法有哪些？GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。OPTIONS：查询相应URI支持的HTTP方法。 2.FTP 是File Transfer Protocol（文件传输协议）:用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。 在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。 “下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。 用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 4.POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。","categories":[],"tags":[]},{"title":"线程与进程笔记","slug":"计算机系统","date":"2019-06-28T05:46:16.000Z","updated":"2019-07-08T07:19:13.211Z","comments":true,"path":"2019/06/28/计算机系统/","link":"","permalink":"http://yoursite.com/2019/06/28/计算机系统/","excerpt":"","text":"银行家算法：避免死锁 资源有序分配法：预防死锁 资源分配图化简法：检测死锁 撤销进程法：解决死锁 -———————————————————————————– 进程和线程的区别进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。进程与线程的区别：1.进程有独立的进程空间，进程中的数据存放空间（堆空间和栈空间）是独立的。2.线程的堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，二者之间可以相互影响。线程的数据交换更快，因为他们在同一地址空间内多进程里，子进程可获得父进程的所有堆和栈的数据；进程比线程更健壮，但是进程比线程更容易杀掉-————————————————————————————————————————操作系统之进程的几种状态就绪(Ready)状态:当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。执行状态:进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。阻塞状态:正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态.-————————————————————————————————————–操作系统中的死锁被定义为系统中两个或者多个进程无限期地等待永远不会发生的条件，系统处于停滞状态，这就是死锁。产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。如何确保N个线程可以访问N个资源同时又不导致死锁？使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。-——————————————————————————————————线程间通信:共享存储.消息传递.管道通信共享存储 1.低级方式:基于数据结构的共享 2.高级方式:基于存储区的共享消息传递 1.直接通信方式:直接把消息挂到接收进程的消息队列 2.间接通信方式:找到某个中间实体.接收进程找实体接收消息.类似电子邮件.管道通信 利用一种特殊的pipe文件连接两个进程,管道只能单向传输(半双工)当缓冲区还有数据时,写进程不会往缓冲区写数据.java中的线程通信 1.同步 synchronized 共享存储 2.while轮询 3.wait().notify()机制并发和并行 并发:一个处理器同时处理多个任务.(根本不可能同时进行一个以上的线程,只能把cpu运行时间分成若干个时间段, 再讲时间段分配给各个线程执行.在一个线程运行期间,其他线程处于挂起状态) 并行:多个处理器或者多核处理器同时处理多个不同的任务.-———————————————————————————-线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。(1)生命周期的五种状态 新建（new Thread）当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：Thread t1=new Thread();就绪（runnable）线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源。例如：t1.start();运行（running）线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。死亡（dead）当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。自然终止：正常运行run()方法后终止异常终止：调用stop()方法让一个线程终止运行堵塞（blocked）由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。正在等待：调用wait()方法。（调用motify()方法回到就绪状态）被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）2.常用方法void run() 创建该类的子类时必须实现的方法void start() 开启线程的方法static void sleep(long t) 释放CPU的执行权，不释放锁static void sleep(long millis,int nanos)final void wait()释放CPU的执行权，释放锁final void notify()static void yied()可以对当前线程进行临时暂停（让线程将资源释放出来）3.（1）结束线程原理：就是让run方法结束。而run方法中通常会定义循环结构，所以只要控制住循环即可(2)方法—-可以boolean标记的形式完成，只要在某一情况下将标记改变，让循环停止即可让线程结束（3）public final void join()//让线程加入执行，执行某一线程join方法的线程会被冻结，等待某一线程执行结束，该线程才会恢复到可运行状态\\4. 临界资源：多个线程间共享的数据称为临界资源（1）互斥锁a.每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。b.Java对象默认是可以被多个线程共用的，只是在需要时才启动“互斥锁”机制，成为专用对象。c.关键字synchronized用来与对象的互斥锁联系d.当某个对象用synchronized修饰时，表明该对象已启动“互斥锁”机制，在任一时刻只能由一个线程访问，即使该线程出现堵塞，该对象的被锁定状态也不会解除，其他线程任不能访问该对象。","categories":[],"tags":[]},{"title":"双指针题","slug":"双指针","date":"2019-06-13T05:46:16.000Z","updated":"2019-06-13T02:31:36.987Z","comments":true,"path":"2019/06/13/双指针/","link":"","permalink":"http://yoursite.com/2019/06/13/双指针/","excerpt":"","text":"双指针(Two Pointers)一直是程序员面试中的一个必须准备的主题， 面试中双指针出现的次数比较多，主要由于在工作中指针经常用到，指针问题能够直接反应面试者的基础知识、代码能力和思维逻辑，因此双指针的问题必须掌握。 解决双指针问题三种常用思想： 左右指针：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇快慢指针：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾后序指针：常规指针操作是从前向后便利，对于合并和替换类型题，防止之前的数据被覆盖，双指针需从后向前便利记忆口诀：左右指针中间夹，快慢指针走到头，后序指针往回走LeetCode中关于双指针的题目有以下三种类型题： (一)双指针之左右指针相关题目： (二)双指针之快慢指针相关题目： (三)双指针之后序指针相关题目： (一)双指针之左右指针相关题目： Two Sum II - Input array is sorted Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2题目要求：给定一个升序排列的整数数组，找到两个数，使它们的和等于给定的数，有且仅有一个满足条件的解，返回索引。题目分析：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止。题目解答：class Solution {public: vector twoSum(vector&amp; numbers, int target) { vector res(2, -1); int left = 0, right = numbers.size() - 1; while(left &lt; right){ int temp = numbers[left] + numbers[right]; if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ res[0] = left + 1; res[1] = right + 1; return res; } } return res; }}; 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，满足a + b + c = 0？ 找到数组中所有的三元组。注意：解决方案中不得包含重复的三元组。题目分析：尝试把三数和问题转化为两数和问题：同样先对数组排序，设置三个指针i,left,right，i指针指向第一个数x，则left,right要指向数组中剩余数中的两个，并且指向的两数和为-x，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; threeSum(vector&amp; nums) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 2) return res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; -nums[i]){ right–; }else if(temp &lt; -nums[i]){ left++; }else{ vector tmp{nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.题目要求：这道题让我们求最接近给定值的三数之和。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量small用来记录差的绝对值。题目解答：class Solution {public: int threeSumClosest(vector&amp; nums, int target) { int n = nums.size(), res = INT_MIN, small = INT_MAX; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right] + nums[i]; if(abs(temp - target) &lt; small){ res = temp; small = abs(temp - target); } if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ return target; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，d 满足a + b + c + d= target？ 找到数组中所有的四元组。注意：解决方案中不得包含重复的四元组。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，尝试把四数和问题转化为两数和问题：同样先对数组排序，设置四个指针k,i,left,right，k指针指向第一个数，i指针指向第二个数,则left,right要指向数组中剩余数中的两个，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; fourSum(vector&amp; nums, int target) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 3) return res; sort(nums.begin(), nums.end()); for(int k = 0; k &lt; n-3; k++){ for(int i = k + 1; i &lt; n-2; i++){ int left = i + 1, right = n - 1; int ret = target - nums[k] - nums[i]; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; ret){ right–; }else if(temp &lt; ret){ left++; }else{ vector tmp{nums[k], nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } while(k + 1 &lt; n -3 &amp;&amp; nums[k] == nums[k + 1]) k++; } return res; }}; Container With Most Water Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.题目要求：给定n个非负整数a1, a2, …, an, 每个都代表坐标轴上的高，其坐标为（i,ai）。可以根据这条数组构建一幅柱形图，每任意两条柱子形成一个水桶，要求找到能盛最多水的水桶的面积。题目分析：两条垂直的线和X轴组成一个容器，灌水多少不仅与两个柱子的高度有关，也与两个柱子的距离有关，公式：S(i,j) = min(ai, aj) * (j-i)，容器不能倾斜，求容纳最多水的两个线组合。定义left和right两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离题目解答：class Solution {public: int maxArea(vector&amp; height) { int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right){ int temp = min(height[right], height[left]); res = max(res, temp*(right - left)); if(height[right] &lt; height[left]) right–; else left++; } return res; }}; Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.题目要求：给定一个数组，每个元素表示海报高度，每个元素宽度均为 1 ，求这个数组能装多少雨水。题目分析：看一种只需要遍历一次即可的解法，这个算法需要left和right两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至left和right指针重合。题目解答：class Solution {public: int trap(vector&amp; height) { int res = 0, left = 0, right = height.size() - 1; int maxleft = 0, maxright = 0; while(left &lt; right){ if(height[left] &lt; height[right]){ if(height[left] &gt; maxleft){ maxleft = height[left]; }else{ res += maxleft - height[left]; } left++; }else{ if(height[right] &gt; maxright){ maxright = height[right]; }else{ res += maxright - height[right]; } right–; } } return res; }};(二)双指针之快慢指针相关题目： Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.题目要求：这道题让我们移除一个数组中和给定值相同的数字，并返回新的数组的长度。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不满足指定的值，slow指针前进一步，这样不满足条件的整数都被移动到数组的前面。题目解答：class Solution {public: int removeElement(vector&amp; nums, int val) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != val) nums[slow++] = nums[fast]; fast++; } return slow; }}; Move Zeroes Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.题目要求：这道题让我们将一个给定数组中所有的0都移到后面，把非零数前移，要求不能改变非零数的相对应的位置关系，而且不能拷贝额外的数组。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不等于0，slow指针前进一步，这样不等于0的整数都被移动到数组的前面。题目解答：class Solution {public: void moveZeroes(vector&amp; nums) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != 0) swap(nums[slow++], nums[fast]); fast++; } }}; Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.题目要求：这道题要我们从有序数组中去除重复项。题目分析：这道题的解题思路是，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第2个数字，如果快指针指向的数等于慢指针的前1个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 1, fast = 1, n = nums.size(); if(n &lt;= 1) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 1]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.题目要求：这道题要我们从有序数组中去除重复项，每个数最多重复出现2次。题目分析：与上一道解题思路相似，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第3个数字，如果快指针指向的数等于慢指针的前2个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 2, fast = 2, n = nums.size(); if(n &lt;= 2) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 2]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.题目要求：在一个长度为n+1的数组中，每个数都是1-n之间，只有一个数出现两次，其他的数都只出现过一次，请找出这个数。题目分析：核心思想快慢指针，由于题目限定了区间[1,n]，所以可以巧妙的利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，我们用快慢指针可以找到环并确定环的起始位置，确实是太巧妙了！题目解答：class Solution {public: int findDuplicate(vector&amp; nums) { int slow = nums[0], fast = nums[nums[0]]; while(slow != fast){ slow = nums[slow]; fast = nums[nums[fast]]; } fast = 0; while(slow != fast){ slow = nums[slow]; fast = nums[fast]; } return slow; }};(三)双指针之后序指针相关题目： Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.题目要求：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1中，使得 num1 成为一个有序数组。你可以假设 nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。在 nums1 和 nums2 中初始化的元素的数量分别是 m 和 n。题目分析：算法思想是：由于合并后A数组的大小必定是m+n，所以从最后面开始往前赋值，先比较A和B中最后一个元素的大小，把较大的那个插入到m+n-1的位置上，再依次向前推。如果A中所有的元素都比B小，那么前m个还是A原来的内容，没有改变。如果A中的数组比B大的，当A循环完了，B中还有元素没加入A，直接用个循环把B中所有的元素覆盖到A剩下的位置。题目解答：class Solution {public: void merge(vector&amp; nums1, int m, vector&amp; nums2, int n) { int i = m - 1, j = n - 1, k = m + n -1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ if(nums1[i] &gt; nums2[j]) nums1[k–] = nums1[i–]; else nums1[k–] = nums2[j–]; } while(j &gt;= 0) nums1[k–] = nums2[j–]; }","categories":[],"tags":[]},{"title":"","slug":"二叉树","date":"2019-06-13T02:29:21.353Z","updated":"2019-06-13T02:29:21.532Z","comments":true,"path":"2019/06/13/二叉树/","link":"","permalink":"http://yoursite.com/2019/06/13/二叉树/","excerpt":"","text":"二叉树是一种非常重要的数据结构，非常多其他数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们寻常所说的层次遍历。由于树的定义本身就是递归定义，因此採用递归的方法去实现树的三种遍历不仅easy理解并且代码非常简洁，而对于广度遍历来说，须要其他数据结构的支撑。比方堆了。所以。对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。 四种基本的遍历思想为： 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树 中序遍历：左子树—&gt; 根结点 —&gt; 右子树 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点 层次遍历：仅仅需按层次遍历就可以 比如。求以下二叉树的各种遍历 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 一、前序遍历 1）依据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，非常easy写出递归版本号： public void preOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ System.out.print(root.val+” “); ​ preOrderTraverse1(root.left); ​ preOrderTraverse1(root.right); ​ } ​ } 2）如今讨论非递归的版本号： 依据前序遍历的顺序，优先訪问根结点。然后在訪问左子树和右子树。所以。对于随意结点node。第一部分即直接訪问之，之后在推断左子树是否为空，不为空时即反复上面的步骤，直到其为空。若为空。则须要訪问右子树。注意。在訪问过左孩子之后。须要反过来訪问其右孩子。所以，须要栈这样的数据结构的支持。对于随意一个结点node，详细过程例如以下： a)訪问之，并把结点node入栈。当前结点置为左孩子； b)推断结点node是否为空，若为空。则取出栈顶结点并出栈，将右孩子置为当前结点；否则反复a)步直到当前结点为空或者栈为空（能够发现栈中的结点就是为了訪问右孩子才存储的） 代码例如以下： public void preOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ System.out.print(pNode.val+” “); ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ pNode = node.right; ​ } ​ } ​ } 二、中序遍历 1)依据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，非常easy写出递归版本号： public void inOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ inOrderTraverse1(root.left); ​ System.out.print(root.val+” “); ​ inOrderTraverse1(root.right); ​ } ​ } 2）非递归实现，有了上面前序的解释，中序也就比較简单了。同样的道理。仅仅只是訪问的顺序移到出栈时。代码例如以下： public void inOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ pNode = node.right; ​ } ​ } ​ } 三、后序遍历 1）依据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点。非常easy写出递归版本号： public void postOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ postOrderTraverse1(root.left); ​ postOrderTraverse1(root.right); ​ System.out.print(root.val+” “); ​ } ​ } 2） 后序遍历的非递归实现是三种遍历方式中最难的一种。由于在后序遍历中，要保证左孩子和右孩子都已被訪问而且左孩子在右孩子前訪问才干訪问根结点，这就为流程的控制带来了难题。以下介绍两种思路。 ​ 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索。直到搜索到没有左孩子的结点，此时该结点出如今栈顶，可是此时不能将其出栈并訪问，因此其右孩子还为被訪问。 所以接下来依照同样的规则对其右子树进行同样的处理，当訪问完其右孩子时。该结点又出如今栈顶，此时能够将其出栈并訪问。这样就保证了正确的訪问顺序。能够看出，在这个过程中，每一个结点都两次出如今栈顶，仅仅有在第二次出如今栈顶时，才干訪问它。因此须要多设置一个变量标识该结点是否是第一次出如今栈顶。 123456789101112131415161718192021222324252627282930313233void postOrder2(BinTree *root) //非递归后序遍历&#123; stack&lt;BTNode*&gt; s; BinTree *p=root; BTNode *temp; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) //沿左子树一直往下搜索。直至出现没有左子树的结点 &#123; BTNode *btn=(BTNode *)malloc(sizeof(BTNode)); btn-&gt;btnode=p; btn-&gt;isFirst=true; s.push(btn); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; temp=s.top(); s.pop(); if(temp-&gt;isFirst==true) //表示是第一次出如今栈顶 &#123; temp-&gt;isFirst=false; s.push(temp); p=temp-&gt;btnode-&gt;rchild; &#125; else //第二次出如今栈顶 &#123; cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;; p=NULL; &#125; &#125; &#125; &#125; ​ 另外一种思路：要保证根结点在左孩子和右孩子訪问之后才干訪问，因此对于任一结点P。先将其入栈。假设P不存在左孩子和右孩子。则能够直接訪问它；或者P存在左孩子或者右孩子。可是其左孩子和右孩子都已被訪问过了。则相同能够直接訪问该结点。若非上述两种情况。则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被訪问。左孩子和右孩子都在根结点前面被訪问。 12345678910111213141516171819202122232425void postOrder3(BinTree *root) //非递归后序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *cur; //当前结点 BinTree *pre=NULL; //前一次訪问的结点 s.push(root); while(!s.empty()) &#123; cur=s.top(); if((cur-&gt;lchild==NULL&amp;&amp;cur-&gt;rchild==NULL)|| (pre!=NULL&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild))) &#123; cout&lt;&lt;cur-&gt;data&lt;&lt;&quot; &quot;; //假设当前结点没有孩子结点或者孩子节点都已被訪问过 s.pop(); pre=cur; &#125; else &#123; if(cur-&gt;rchild!=NULL) s.push(cur-&gt;rchild); if(cur-&gt;lchild!=NULL) s.push(cur-&gt;lchild); &#125; &#125; &#125; 四、层次遍历 层次遍历的代码比較简单。仅仅须要一个队列就可以。先在队列中增加根结点。之后对于随意一个结点来说。在其出队列的时候，訪问之。同一时候假设左孩子和右孩子有不为空的。入队列。代码例如以下： public void levelTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList queue = new LinkedList&lt;&gt;(); ​ queue.offer(root); ​ while (!queue.isEmpty()) { ​ TreeNode node = queue.poll(); ​ System.out.print(node.val+” “); ​ if (node.left != null) { ​ queue.offer(node.left); ​ } ​ if (node.right != null) { ​ queue.offer(node.right); ​ } ​ } ​ } 五、深度优先遍历 事实上深度遍历就是上面的前序、中序和后序。可是为了保证与广度优先遍历相照顾，也写在这。代码也比較好理解，事实上就是前序遍历，代码例如以下： [java] view plain copy public void depthOrderTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ stack.push(root); ​ while (!stack.isEmpty()) { ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ if (node.right != null) { ​ stack.push(node.right); ​ } ​ if (node.left != null) { ​ stack.push(node.left); ​ } ​ } ​ }","categories":[],"tags":[]},{"title":"Image","slug":"images","date":"2019-05-24T08:47:12.411Z","updated":"2019-05-24T09:10:40.928Z","comments":true,"path":"2019/05/24/images/","link":"","permalink":"http://yoursite.com/2019/05/24/images/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDBC学习","slug":"笔记（一） - 副本","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:20:09.849Z","comments":true,"path":"2019/05/24/笔记（一） - 副本/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一） - 副本/","excerpt":"","text":"事务&amp;数据库连接池&amp;DBUtils事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库rollback ; 数据回滚，回到最初的状态。 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); 12345678910111213141516171819@Testpublic void testTransaction()&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); ​ 总结事务123使用命令行演示使用代码演示 脏读、 不可重复读、 幻读丢失更新 12345678悲观锁乐观锁4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 12queryRunner.update();queryRunner.query","categories":[],"tags":[]},{"title":"java静态代理与动态代理","slug":"代理设计模式","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:30:57.674Z","comments":true,"path":"2019/05/24/代理设计模式/","link":"","permalink":"http://yoursite.com/2019/05/24/代理设计模式/","excerpt":"","text":"代理模式简介代理模式（proxy）指的是为一个对象提供一个代理以控制外界对该对象的访问，比如有些情况下对象A不能直接访问对象B，此时可以为对象B创建一个代理C，然后对象A通过访问代理C来间接访问对象B。比如你看上了你女性朋友的闺蜜，此时你可以通过你的朋友来跟她闺蜜进行一些沟通。有的时候我们希望增强某个方法的功能，但是有不方便直接修改该方法，此时也可通过代理来实现，即在该方法执行的前后做一些事情。比如你要打官司，但是法律上的事情你可能不清楚，此时需要请一名代理律师，让这个代理律师帮助你去做一些事情。 代理的模式的优点： 提高程序的扩展性和可复用性 保护目标对象 代理模式分为两种：静态代理和动态代理。 静态代理代理类和相关的方法直接在代码中写死。下面以你看上了你女性朋友娜娜的闺蜜小曼举例： 首先定义一个接口： 1234567891011package com.monkey1024.proxy.staticproxy;/** * 女神 */public interface Beauty &#123; void eat();&#125; 创建小曼的类并实现上面的接口： 12345678910111213package com.monkey1024.proxy.staticproxy;/** * 你的目标对象小曼 * 你女性朋友娜娜的闺蜜 */public class XiaoMan implements Beauty &#123; @Override public void eat() &#123; System.out.println(&quot;小曼吃饭&quot;); &#125;&#125; 创建娜娜的类实现上面接口，娜娜是中间人，所以实现方式不太一样，这里的eat方法中要调用目标对象上的eat方法： 123456789101112131415161718192021222324package com.monkey1024.proxy.staticproxy;/** * 中间人，你的女性朋友娜娜 */public class NaNa implements Beauty &#123; private Beauty beauty; /** * 通过构造方法传入目标对象 * @param beauty */ public NaNa(Beauty beauty) &#123; this.beauty = beauty; &#125; @Override public void eat() &#123; //调用目标对象上的吃饭方法 beauty.eat(); &#125;&#125; 创建你的类，里面添加交朋友的方法： 1234567891011121314151617package com.monkey1024.proxy.staticproxy;public class You &#123; private Beauty beauty; public You(Beauty beauty) &#123; this.beauty = beauty; &#125; /** * 交朋友 */ public void makeFriend() &#123; beauty.eat(); &#125;&#125; 创建测试类： 12345678910111213package com.monkey1024.proxy.staticproxy;public class Test &#123; public static void main(String[] args) &#123; XiaoMan xiaoMan = new XiaoMan(); NaNa naNa = new NaNa(xiaoMan); You you = new You(naNa); you.makeFriend(); &#125;&#125; 动态代理动态代理它可以直接给某一个目标对象生成一个代理对象，而不需要代理类存在。动态代理与静态代理原理是一样的，只是它没有具体的代理类，直接在程序运行时动态生成了一个代理对象。 动态代理的技术实现： JDK提供的动态代理，底层使用反射原理，只能创建接口的代理。 cglib，底层是通过使用一个小而快的字节码处理框架ASM，可以创建类和接口的代理。 jdk的动态代理： Proxy.newProxyInstance():产生代理接口的实例。仅能代理实现至少一个接口的类 ClassLoader：类加载器。即被代理的接口的类加载器。 Class[] interface：被代理对象的父接口 InvocationHandler：将要在代理中实现的功能写在该对象中 InvocationHandler中的invoke方法：调用代理类的任何方法，此方法都会执行 Object proxy:代理对象自身的引用。 Method method:当前被调用的方法。 Object[] args:当前被调用方法用到的参数 只需要将之前的测试类中的代码修改为下面的内容即可： 12345678910111213141516171819202122232425262728293031package com.monkey1024.proxy.staticproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; Beauty xiaoMan = new XiaoMan(); //不需要自己创建代理了 //NaNa naNa = new NaNa(xiaoMan); //由jdk动态的为你创建一个代理 Beauty proxy = (Beauty)Proxy.newProxyInstance(xiaoMan.getClass().getClassLoader(), xiaoMan.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;吃饭之前的准备&quot;); Object invoke = method.invoke(xiaoMan); System.out.println(&quot;吃饭之后的结果&quot;); return invoke; &#125; &#125;); You you = new You(proxy); you.makeFriend(); &#125;&#125; 调用有参数的方法在彼此认识之后，你打算送小曼礼物，此时将之前的代码稍作修改： 在接口中新增gift方法，count表示礼物的数量： 1void gift(int count); 在XiaoMan的类中添加gift方法的重写： 1234@Overridepublic void gift(int count) &#123; System.out.println(&quot;收到&quot; + count + &quot;礼物&quot;);&#125; 在You类中添加show方法用来送礼物： 123456/** * 展示 */public void show()&#123; beauty.gift(10);&#125; 修改之前的测试类如下，送礼物的时候，为了感谢代理人，所以每次会把礼物分一半给代理人： 1234567891011121314151617181920212223242526Beauty xiaoMan = new XiaoMan(); //不需要自己创建代理了 //NaNa naNa = new NaNa(xiaoMan); //由jdk动态的为你创建一个代理 Beauty proxy = (Beauty)Proxy.newProxyInstance(xiaoMan.getClass().getClassLoader(), xiaoMan.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;准备&quot;); Object invoke = null; if (&quot;gift&quot;.equals(method.getName()))&#123; invoke = method.invoke(xiaoMan,new Object[]&#123;(Integer)args[0]/2&#125;); &#125;else&#123; invoke = method.invoke(xiaoMan); &#125; System.out.println(&quot;结果&quot;); return invoke; &#125; &#125;); You you = new You(proxy); you.makeFriend(); you.show();","categories":[],"tags":[]},{"title":"Hexo学习（一）","slug":"笔记（一）","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:19:19.405Z","comments":true,"path":"2019/05/24/笔记（一）/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一）/","excerpt":"","text":"Hexo学习（一）此文介绍Hexo建站的流程…特别鸣谢 指导人 CodeSheep 从此打开新的大门let‘s go 01.安装 Node.j打开官方网站 https://nodejs.org 02.安装 Git打开官方网站 https://git-scm.com/downloads 然后我们选择windows版本的下载 安装也是一直点下一步，安装官方默认的来就行，完了，在开始菜单可以看到 tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。 03.安装hexo新建一个文件夹，比如我这里建了 ==blog4==打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==看看 ==node，npm== 是否安装成功，没有成功的就重新安装node。 我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm在上面终端继续输入npm install -g cnpm --registry=https://registry.npm.taobao.org测试cnpm-成功！ ==完成之后安装hexo==cnpm install -g hexo-cli 验证是否安装成功hexo -v出现,说明成功 1234567891011121314151617hexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.3v8: 6.8.275.32-node.51uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 首先看看当前路径命令pwd结果为Administrator@XTZ-01804162214 MINGW64 ~/Desktop/blog4然后我们运行命令，这步是关键，主要是建立整个项目，这里我的文件夹名字是kuku，文件夹位置是桌面上。hexo init结果如下： 04.运行测试这里我们经常用到的有三个命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 我们运行hexo s 打开浏览器，输入localhost:4000,看到 说明本地环境搭建完成。。。其余的内容请看下一篇文章。","categories":[],"tags":[]},{"title":"工厂设计模式","slug":"工厂设计模式","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:39:28.259Z","comments":true,"path":"2019/05/24/工厂设计模式/","link":"","permalink":"http://yoursite.com/2019/05/24/工厂设计模式/","excerpt":"","text":"工厂模式简介工厂模式就是用工厂提供的方法代替了使用new创建对象的操作, 将创建对象统一管理和控制从而将调用者与实现类进行解耦，实现了创建者与调用者的分离。例如MyBatis中SqlSessionFactory创建SqlSession，这个就使用了工厂模式。工厂模式的分类： 简单工厂模式（静态工厂） 工厂方法模式 抽象工厂 简单工厂模式有的地方也叫作静态工厂，实际上它并不算是设计模式，只不过算是工厂方法和抽象工厂的基础，不过也有一些运用的地方。比如jdk的动态代理的Proxy.newProxyInstance这个就是一个简单工厂，另外Calendar.getInstance也是一个简单的工厂。比如你接到了生产苹果手机的订单，此时你需要建一个工厂去生产苹果手机，这里就生产iPhone X和iPhone 8 plus两款手机。 先创建一个iPhone手机的接口： 1234567/** * 苹果手机 */public interface IPhone &#123; void play();&#125; 创建IPhoneX系列手机 12345678910/** * iPhone X系列手机 */public class IPhoneX implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建iPhone 8 plus系列手机 12345678910/** * iPhone 8 Plus系列手机 */public class IPhone8Plus implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhone8Plus&quot;); &#125;&#125; 创建生产苹果手机的工厂： 123456789101112131415161718192021/** * iPhone工厂 */public class IPhoneFactory &#123; public static IPhone produce(String model)&#123; if (&quot;iPhoneX&quot;.equalsIgnoreCase(model)) &#123; //生产iPhoneX return new IPhoneX(); &#125; else if (&quot;iPhone8Plus&quot;.equalsIgnoreCase(model)) &#123; //生产iPhone 8 Plus return new IPhone8Plus(); &#125;else &#123; //不生产任何东西 return null; &#125; &#125;&#125; 创建测试类： 12345678public class Test01 &#123; public static void main(String[] args) &#123; //生产iPhone X手机 IPhone iPhone = IPhoneFactory.produce(&quot;iPhoneX&quot;); iPhone.play(); &#125;&#125; 静态工厂优点：通过以上代码可以看出来静态工厂的优点是封装了苹果手机创建的过程，对于使用者来说，直接调用工厂的方法就可以获取想要的手机了。 静态工厂缺点扩展性差，倘若要想再生产iPhone 8系列手机的话，需要修改的代码比较多。 工厂方法工厂方法模式的实质是定义一个用于创建对象的接口，然后让实现这个接口的类来决定创建哪个类的对象。这里还是以生产iPhone X和iPhone 8 plus手机为例。创建iphone接口： 1234public interface IPhone &#123; void play();&#125; 创建iPhone 8 plus手机： 1234567public class IPhone8Plus implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhone8Plus&quot;); &#125;&#125; 创建iPhone X手机： 1234567public class IPhoneX implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建生产手机的大工厂： 12345678/** * iPhone大工厂 */public interface IPhoneFactory &#123; IPhone produce();&#125; 创建生产IPhoneX的工厂： 12345678910/** * 生产iphonex的工厂 */public class IPhoneXFactory implements IPhoneFactory &#123; @Override public IPhoneX produce() &#123; return new IPhoneX(); &#125;&#125; 创建生产iPhone 8 plus的工厂： 1234567public class IPhone8PlusFactory implements IPhoneFactory &#123; @Override public IPhone8Plus produce() &#123; return new IPhone8Plus(); &#125;&#125; 创建测试类： 12345678public class Test02 &#123; public static void main(String[] args) &#123; IPhone8PlusFactory iPhone8PlusFactory = new IPhone8PlusFactory(); IPhone8Plus iPhone8Plus = iPhone8PlusFactory.produce(); iPhone8Plus.play(); &#125;&#125; 工厂方法模式相对于静态工厂而言在虽然代码量多了一些，但是在程序的扩展性上要更好，倘若再加入生产iPhone 8手机的工厂，是不需要修改现有的工厂的。 抽象工厂抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。产品族就是一系列相关的产品，比如生产手机，还需要生产相应的充电器，手机和充电器就相当于是两个产品族，手机可以生产苹果手机、小米手机等，充电器可以生产苹果充电器、小米充电器等。 定义充电器的接口： 1234567/** * 充电器 */public interface Charger &#123; void charge();&#125; 定义手机的接口： 1234567/** * 手机 */public interface Telephone &#123; void play();&#125; 创建苹果手机充电器的类： 12345678910/** * 苹果手机充电器 */public class AppleCharger implements Charger &#123; @Override public void charge() &#123; System.out.println(&quot;给苹果手机充电&quot;); &#125;&#125; 创建小米手机充电器的类： 12345678910/** * 小米手机充电器 */public class XiaoMiCharger implements Charger &#123; @Override public void charge() &#123; System.out.println(&quot;给小米手机充电&quot;); &#125;&#125; 创建iPhone X手机的类： 12345678910/** * IPhoneX手机 */public class IPhoneX implements Telephone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建小米8手机的类： 12345678910/** * XiaoMi8手机 */public class XiaoMi8 implements Telephone &#123; @Override public void play() &#123; System.out.println(&quot;小米8&quot;); &#125;&#125; 创建生产手机的大工厂： 1234567891011/** * 生产手机的大工厂 * * 要生产手机和相应的充电器 */public interface PhoneFactory &#123; Charger produceCharger(); Telephone producePhone();&#125; 创建生产iPhone X手机的工厂： 123456789101112131415/** * 生产苹果手机的工厂 */public class IPhoneXFactory implements PhoneFactory &#123; @Override public Charger produceCharger() &#123; return new AppleCharger(); &#125; @Override public Telephone producePhone() &#123; return new IPhoneX(); &#125;&#125; 创建生产小米8手机的工厂： 123456789101112public class XiaoMi8Factory implements PhoneFactory &#123; @Override public Charger produceCharger() &#123; return new XiaoMiCharger(); &#125; @Override public Telephone producePhone() &#123; return new XiaoMi8(); &#125;&#125; 创建测试类： 12345678910public class Test03 &#123; public static void main(String[] args) &#123; IPhoneXFactory iPhoneXFactory = new IPhoneXFactory(); Charger charger = iPhoneXFactory.produceCharger(); Telephone iPhoneX = iPhoneXFactory.producePhone(); charger.charge(); iPhoneX.play(); &#125;&#125; 工厂方法和抽象工厂的区别在于工厂方法的一个工厂只能创建一个具体产品。而抽象工厂的一个工厂可以创建属于一类类型的多种具体产品。 三种方式的总结静态工厂 ： 用来生产同一等级结构中的任意产品。产品的创建是由你传入参数决定的。 工厂方法 ：用来生产同一等级结构中的固定产品。一个工厂只能生产一个固定的产品。 抽象工厂 ：用来生产不同产品族的全部产品。一个工厂可以生产跟该产品相关的一系列产品。","categories":[],"tags":[]},{"title":"Timer学习","slug":"Timer","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:37:26.590Z","comments":true,"path":"2019/05/24/Timer/","link":"","permalink":"http://yoursite.com/2019/05/24/Timer/","excerpt":"","text":"一、简介​ 在java中一个完整定时任务需要由Timer、TimerTask两个类来配合完成。 API中是这样定义他们的，Timer：一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。由TimerTask：Timer 安排为一次执行或重复执行的任务。我们可以这样理解Timer是一种定时器工具，用来在一个后台线程计划执行指定任务，而TimerTask一个抽象类，它的子类代表一个可以被Timer计划的任务。 Timer类​ 在工具类Timer中，提供了四个构造方法，每个构造方法都启动了计时器线程，同时Timer类可以保证多个线程可以共享单个Timer对象而无需进行外部同步，所以Timer类是线程安全的。但是由于每一个Timer对象对应的是单个后台线程，用于顺序执行所有的计时器任务，一般情况下我们的线程任务执行所消耗的时间应该非常短，但是由于特殊情况导致某个定时器任务执行的时间太长，那么他就会“独占”计时器的任务执行线程，其后的所有线程都必须等待它执行完，这就会延迟后续任务的执行，使这些任务堆积在一起，具体情况我们后面分析。 ​ 当程序初始化完成Timer后，定时任务就会按照我们设定的时间去执行，Timer提供了schedule方法，该方法有多中重载方式来适应不同的情况，如下： ​ schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务。 ​ schedule(TimerTask task, Date firstTime, long period) ：安排指定的任务在指定的时间开始进行重复的固定延迟执行。 ​ schedule(TimerTask task, long delay) ：安排在指定延迟后执行指定的任务。 ​ schedule(TimerTask task, long delay, long period) ：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。 ​ 同时也重载了scheduleAtFixedRate方法，scheduleAtFixedRate方法与schedule相同，只不过他们的侧重点不同，区别后面分析。 ​ scheduleAtFixedRate(TimerTask task, Date firstTime, long period)：安排指定的任务在指定的时间开始进行重复的固定速率执行。 ​ scheduleAtFixedRate(TimerTask task, long delay, long period)：安排指定的任务在指定的延迟后开始进行重复的固定速率执行。 TimerTask​ TimerTask类是一个抽象类，由Timer 安排为一次执行或重复执行的任务。它有一个抽象方法run()方法，该方法用于执行相应计时器任务要执行的操作。因此每一个具体的任务类都必须继承TimerTask，然后重写run()方法。 ​ 另外它还有两个非抽象的方法： ​ boolean cancel()：取消此计时器任务。 ​ long scheduledExecutionTime()：返回此任务最近实际执行的安排执行时间。 二、实例2.1、指定延迟时间执行定时任务[java] view plain copy public class TimerTest01 { ​ Timer timer; ​ public TimerTest01(int time){ ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest01(), time * 1000); ​ } ​ ​ public static void main(String[] args) { ​ System.out.println(“timer begin….”); ​ new TimerTest01(3); ​ } } public class TimerTaskTest01 extends TimerTask{ ​ public void run() { ​ System.out.println(“Time’s up!!!!”); ​ } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class TimerTest01 &#123; Timer timer; public TimerTest01(int time)&#123; timer = new Timer(); timer.schedule(new TimerTaskTest01(), time * 1000); &#125; public static void main(String[] args) &#123; System.out.println(&quot;timer begin....&quot;); new TimerTest01(3); &#125;&#125; public class TimerTaskTest01 extends TimerTask&#123; public void run() &#123; System.out.println(&quot;Time&apos;s up!!!!&quot;); &#125;&#125; ​ 运行结果： 首先打印：timer begin…. 3秒后打印：Time’s up!!!! 123456789首先打印：timer begin.... 3秒后打印：Time&apos;s up!!!! 2.2、在指定时间执行定时任务[java] view plain copy public class TimerTest02 { ​ Timer timer; ​ ​ public TimerTest02(){ ​ Date time = getTime(); ​ System.out.println(“指定时间time=” + time); ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest02(), time); ​ } ​ ​ public Date getTime(){ ​ Calendar calendar = Calendar.getInstance(); ​ calendar.set(Calendar.HOUR_OF_DAY, 11); ​ calendar.set(Calendar.MINUTE, 39); ​ calendar.set(Calendar.SECOND, 00); ​ Date time = calendar.getTime(); ​ ​ return time; ​ } ​ ​ public static void main(String[] args) { ​ new TimerTest02(); ​ } } public class TimerTaskTest02 extends TimerTask{ ​ @Override ​ public void run() { ​ System.out.println(“指定时间执行线程任务…”); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class TimerTest02 &#123; Timer timer; public TimerTest02()&#123; Date time = getTime(); System.out.println(&quot;指定时间time=&quot; + time); timer = new Timer(); timer.schedule(new TimerTaskTest02(), time); &#125; public Date getTime()&#123; Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.HOUR_OF_DAY, 11); calendar.set(Calendar.MINUTE, 39); calendar.set(Calendar.SECOND, 00); Date time = calendar.getTime(); return time; &#125; public static void main(String[] args) &#123; new TimerTest02(); &#125;&#125; public class TimerTaskTest02 extends TimerTask&#123; @Override public void run() &#123; System.out.println(&quot;指定时间执行线程任务...&quot;); &#125;&#125; ​ 当时间到达11:39:00时就会执行该线程任务，当然大于该时间也会执行！！执行结果为： [java] view plain copy 指定时间time=Tue Jun 10 11:39:00 CST 2014 指定时间执行线程任务… 12345指定时间time=Tue Jun 10 11:39:00 CST 2014指定时间执行线程任务... 2.3、在延迟指定时间后以指定的间隔时间循环执行定时任务[java] view plain copy public class TimerTest03 { ​ Timer timer; ​ ​ public TimerTest03(){ ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest03(), 1000, 2000); ​ } ​ ​ public static void main(String[] args) { ​ new TimerTest03(); ​ } } public class TimerTaskTest03 extends TimerTask{ ​ @Override ​ public void run() { ​ Date date = new Date(this.scheduledExecutionTime()); ​ System.out.println(“本次执行该线程的时间为：” + date); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class TimerTest03 &#123; Timer timer; public TimerTest03()&#123; timer = new Timer(); timer.schedule(new TimerTaskTest03(), 1000, 2000); &#125; public static void main(String[] args) &#123; new TimerTest03(); &#125;&#125; public class TimerTaskTest03 extends TimerTask&#123; @Override public void run() &#123; Date date = new Date(this.scheduledExecutionTime()); System.out.println(&quot;本次执行该线程的时间为：&quot; + date); &#125;&#125; ​ 运行结果: [java] view plain copy 本次执行该线程的时间为：Tue Jun 10 21:19:47 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:49 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:51 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:53 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:55 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:57 CST 2014 …………….. 12345678910111213141516171819202122232425本次执行该线程的时间为：Tue Jun 10 21:19:47 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:49 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:51 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:53 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:55 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:57 CST 2014................. ​ 对于这个线程任务,如果我们不将该任务停止,他会一直运行下去。 ​ 对于上面三个实例，LZ只是简单的演示了一下，同时也没有讲解scheduleAtFixedRate方法的例子，其实该方法与schedule方法一样！ 2.4、分析schedule和scheduleAtFixedRate​ 1、schedule(TimerTask task, Date time)、schedule(TimerTask task, long delay) ​ 对于这两个方法而言，如果指定的计划执行时间scheduledExecutionTime&lt;= systemCurrentTime，则task会被立即执行。scheduledExecutionTime不会因为某一个task的过度执行而改变。 ​ 2、schedule(TimerTask task, Date firstTime, long period)、schedule(TimerTask task, long delay, long period) ​ 这两个方法与上面两个就有点儿不同的，前面提过Timer的计时器任务会因为前一个任务执行时间较长而延时。在这两个方法中，每一次执行的task的计划时间会随着前一个task的实际时间而发生改变，也就是scheduledExecutionTime(n+1)=realExecutionTime(n)+periodTime。也就是说如果第n个task由于某种情况导致这次的执行时间过程，最后导致systemCurrentTime&gt;= scheduledExecutionTime(n+1)，这是第n+1个task并不会因为到时了而执行，他会等待第n个task执行完之后再执行，那么这样势必会导致n+2个的执行实现scheduledExecutionTime放生改变即scheduledExecutionTime(n+2) = realExecutionTime(n+1)+periodTime。所以这两个方法更加注重保存间隔时间的稳定。 ​ 3、scheduleAtFixedRate(TimerTask task, Date firstTime, long period)、scheduleAtFixedRate(TimerTask task, long delay, long period) ​ 在前面也提过scheduleAtFixedRate与schedule方法的侧重点不同，schedule方法侧重保存间隔时间的稳定，而scheduleAtFixedRate方法更加侧重于保持执行频率的稳定。为什么这么说，原因如下。在schedule方法中会因为前一个任务的延迟而导致其后面的定时任务延时，而scheduleAtFixedRate方法则不会，如果第n个task执行时间过长导致systemCurrentTime&gt;= scheduledExecutionTime(n+1)，则不会做任何等待他会立即执行第n+1个task，所以scheduleAtFixedRate方法执行时间的计算方法不同于schedule，而是scheduledExecutionTime(n)=firstExecuteTime +n*periodTime，该计算方法永远保持不变。所以scheduleAtFixedRate更加侧重于保持执行频率的稳定。 三、Timer的缺陷3.1、Timer的缺陷​ Timer计时器可以定时（指定时间执行任务）、延迟（延迟5秒执行任务）、周期性地执行任务（每隔个1秒执行任务），但是，Timer存在一些缺陷。首先Timer对调度的支持是基于绝对时间的，而不是相对时间，所以它对系统时间的改变非常敏感。其次Timer线程是不会捕获异常的，如果TimerTask抛出的了未检查异常则会导致Timer线程终止，同时Timer也不会重新恢复线程的执行，他会错误的认为整个Timer线程都会取消。同时，已经被安排单尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。故如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。 ​ 1、Timer管理时间延迟缺陷 ​ 前面Timer在执行定时任务时只会创建一个线程任务，如果存在多个线程，若其中某个线程因为某种原因而导致线程任务执行时间过长，超过了两个任务的间隔时间，会发生一些缺陷： [java] view plain copy public class TimerTest04 { ​ private Timer timer; ​ public long start; ​ ​ public TimerTest04(){ ​ this.timer = new Timer(); ​ start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ System.out.println(“timerOne invoked ,the time:” + (System.currentTimeMillis() - start)); ​ try { ​ Thread.sleep(4000); //线程休眠3000 ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } ​ }, 1000); ​ } ​ ​ public void timerTwo(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ System.out.println(“timerOne invoked ,the time:” + (System.currentTimeMillis() - start)); ​ } ​ }, 3000); ​ } ​ ​ public static void main(String[] args) throws Exception { ​ TimerTest04 test = new TimerTest04(); ​ ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class TimerTest04 &#123; private Timer timer; public long start; public TimerTest04()&#123; this.timer = new Timer(); start = System.currentTimeMillis(); &#125; public void timerOne()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;timerOne invoked ,the time:&quot; + (System.currentTimeMillis() - start)); try &#123; Thread.sleep(4000); //线程休眠3000 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 1000); &#125; public void timerTwo()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;timerOne invoked ,the time:&quot; + (System.currentTimeMillis() - start)); &#125; &#125;, 3000); &#125; public static void main(String[] args) throws Exception &#123; TimerTest04 test = new TimerTest04(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 按照我们正常思路，timerTwo应该是在3s后执行，其结果应该是： [java] view plain copy timerOne invoked ,the time:1001 timerOne invoked ,the time:3001 12345timerOne invoked ,the time:1001timerOne invoked ,the time:3001 ​ 但是事与愿违，timerOne由于sleep(4000)，休眠了4S，同时Timer内部是一个线程，导致timeOne所需的时间超过了间隔时间，结果： [java] view plain copy timerOne invoked ,the time:1000 timerOne invoked ,the time:5000 12345timerOne invoked ,the time:1000timerOne invoked ,the time:5000 ​ 2、Timer抛出异常缺陷 ​ 如果TimerTask抛出RuntimeException，Timer会终止所有任务的运行。如下： [html] view plain copy public class TimerTest04 { ​ private Timer timer; ​ ​ public TimerTest04(){ ​ this.timer = new Timer(); ​ } ​ ​ public void timerOne(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ throw new RuntimeException(); ​ } ​ }, 1000); ​ } ​ ​ public void timerTwo(){ ​ timer.schedule(new TimerTask() { ​ ​ public void run() { ​ System.out.println(“我会不会执行呢？？”); ​ } ​ }, 1000); ​ } ​ ​ public static void main(String[] args) { ​ TimerTest04 test = new TimerTest04(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class TimerTest04 &#123; private Timer timer; public TimerTest04()&#123; this.timer = new Timer(); &#125; public void timerOne()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; throw new RuntimeException(); &#125; &#125;, 1000); &#125; public void timerTwo()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;我会不会执行呢？？&quot;); &#125; &#125;, 1000); &#125; public static void main(String[] args) &#123; TimerTest04 test = new TimerTest04(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果：timerOne抛出异常，导致timerTwo任务终止。 [java] view plain copy Exception in thread “Timer-0” java.lang.RuntimeException ​ at com.chenssy.timer.TimerTest04$1.run(TimerTest04.java:25) ​ at java.util.TimerThread.mainLoop(Timer.java:555) ​ at java.util.TimerThread.run(Timer.java:505) 12345678910111213Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException at com.chenssy.timer.TimerTest04$1.run(TimerTest04.java:25) at java.util.TimerThread.mainLoop(Timer.java:555) at java.util.TimerThread.run(Timer.java:505) ​ 对于Timer的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer是基于绝对时间的，对系统时间比较敏感，而ScheduledThreadPoolExecutor 则是基于相对时间；Timer是内部是单一线程，而ScheduledThreadPoolExecutor内部是个线程池，所以可以支持多个任务并发执行。 3.2、用ScheduledExecutorService替代Timer​ 1、解决问题一： [java] view plain copy public class ScheduledExecutorTest { ​ private ScheduledExecutorService scheduExec; ​ ​ public long start; ​ ​ ScheduledExecutorTest(){ ​ this.scheduExec = Executors.newScheduledThreadPool(2); ​ this.start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ System.out.println(“timerOne,the time:” + (System.currentTimeMillis() - start)); ​ try { ​ Thread.sleep(4000); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } ​ },1000,TimeUnit.MILLISECONDS); ​ } ​ ​ public void timerTwo(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ System.out.println(“timerTwo,the time:” + (System.currentTimeMillis() - start)); ​ } ​ },2000,TimeUnit.MILLISECONDS); ​ } ​ ​ public static void main(String[] args) { ​ ScheduledExecutorTest test = new ScheduledExecutorTest(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class ScheduledExecutorTest &#123; private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest()&#123; this.scheduExec = Executors.newScheduledThreadPool(2); this.start = System.currentTimeMillis(); &#125; public void timerOne()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerOne,the time:&quot; + (System.currentTimeMillis() - start)); try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,1000,TimeUnit.MILLISECONDS); &#125; public void timerTwo()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerTwo,the time:&quot; + (System.currentTimeMillis() - start)); &#125; &#125;,2000,TimeUnit.MILLISECONDS); &#125; public static void main(String[] args) &#123; ScheduledExecutorTest test = new ScheduledExecutorTest(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果： [java] view plain copy timerOne,the time:1003 timerTwo,the time:2005 12345timerOne,the time:1003timerTwo,the time:2005 ​ 2、解决问题二 ​ [java] view plain copy public class ScheduledExecutorTest { ​ private ScheduledExecutorService scheduExec; ​ ​ public long start; ​ ​ ScheduledExecutorTest(){ ​ this.scheduExec = Executors.newScheduledThreadPool(2); ​ this.start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ throw new RuntimeException(); ​ } ​ },1000,TimeUnit.MILLISECONDS); ​ } ​ ​ public void timerTwo(){ ​ scheduExec.scheduleAtFixedRate(new Runnable() { ​ public void run() { ​ System.out.println(“timerTwo invoked …..”); ​ } ​ },2000,500,TimeUnit.MILLISECONDS); ​ } ​ ​ public static void main(String[] args) { ​ ScheduledExecutorTest test = new ScheduledExecutorTest(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class ScheduledExecutorTest &#123; private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest()&#123; this.scheduExec = Executors.newScheduledThreadPool(2); this.start = System.currentTimeMillis(); &#125; public void timerOne()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; throw new RuntimeException(); &#125; &#125;,1000,TimeUnit.MILLISECONDS); &#125; public void timerTwo()&#123; scheduExec.scheduleAtFixedRate(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerTwo invoked .....&quot;); &#125; &#125;,2000,500,TimeUnit.MILLISECONDS); &#125; public static void main(String[] args) &#123; ScheduledExecutorTest test = new ScheduledExecutorTest(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果： [java] view plain copy timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. …………………… 12345678910111213141516171819202122232425262728293031323334353637timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .............................","categories":[],"tags":[]}]}