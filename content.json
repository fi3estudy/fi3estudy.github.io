{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"欢迎大家!!","date":"2019-05-24T09:29:49.538Z","updated":"2019-05-24T09:29:49.538Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"真正的才智是刚毅的志向。 —— 拿破仑感情有着极大的鼓舞力量，因此，它是一切道德行为的重要前提，谁要是没有强烈的志向，也就不能够热烈地把这个志向体现于事业中。 —— 凯洛夫勇敢坚毅真正之才智乃刚毅之志向。 —— 拿破仑生活赋予我们一种巨大的和无限高贵的礼品，这就是青春：充满着力量，充满着期待志愿，充满着求知和斗争的志向，充满着希望信心和青春。 —— 奥斯特洛夫斯基志向不过是记忆的奴隶，生气勃勃地降生，但却很难成长。 —— 莎士比亚"}],"posts":[{"title":"双指针题","slug":"双指针","date":"2019-06-13T05:46:16.000Z","updated":"2019-06-13T02:31:36.987Z","comments":true,"path":"2019/06/13/双指针/","link":"","permalink":"http://yoursite.com/2019/06/13/双指针/","excerpt":"","text":"双指针(Two Pointers)一直是程序员面试中的一个必须准备的主题， 面试中双指针出现的次数比较多，主要由于在工作中指针经常用到，指针问题能够直接反应面试者的基础知识、代码能力和思维逻辑，因此双指针的问题必须掌握。 解决双指针问题三种常用思想： 左右指针：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇快慢指针：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾后序指针：常规指针操作是从前向后便利，对于合并和替换类型题，防止之前的数据被覆盖，双指针需从后向前便利记忆口诀：左右指针中间夹，快慢指针走到头，后序指针往回走LeetCode中关于双指针的题目有以下三种类型题： (一)双指针之左右指针相关题目： (二)双指针之快慢指针相关题目： (三)双指针之后序指针相关题目： (一)双指针之左右指针相关题目： Two Sum II - Input array is sorted Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2题目要求：给定一个升序排列的整数数组，找到两个数，使它们的和等于给定的数，有且仅有一个满足条件的解，返回索引。题目分析：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止。题目解答：class Solution {public: vector twoSum(vector&amp; numbers, int target) { vector res(2, -1); int left = 0, right = numbers.size() - 1; while(left &lt; right){ int temp = numbers[left] + numbers[right]; if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ res[0] = left + 1; res[1] = right + 1; return res; } } return res; }}; 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，满足a + b + c = 0？ 找到数组中所有的三元组。注意：解决方案中不得包含重复的三元组。题目分析：尝试把三数和问题转化为两数和问题：同样先对数组排序，设置三个指针i,left,right，i指针指向第一个数x，则left,right要指向数组中剩余数中的两个，并且指向的两数和为-x，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; threeSum(vector&amp; nums) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 2) return res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; -nums[i]){ right–; }else if(temp &lt; -nums[i]){ left++; }else{ vector tmp{nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.题目要求：这道题让我们求最接近给定值的三数之和。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量small用来记录差的绝对值。题目解答：class Solution {public: int threeSumClosest(vector&amp; nums, int target) { int n = nums.size(), res = INT_MIN, small = INT_MAX; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right] + nums[i]; if(abs(temp - target) &lt; small){ res = temp; small = abs(temp - target); } if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ return target; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，d 满足a + b + c + d= target？ 找到数组中所有的四元组。注意：解决方案中不得包含重复的四元组。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，尝试把四数和问题转化为两数和问题：同样先对数组排序，设置四个指针k,i,left,right，k指针指向第一个数，i指针指向第二个数,则left,right要指向数组中剩余数中的两个，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; fourSum(vector&amp; nums, int target) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 3) return res; sort(nums.begin(), nums.end()); for(int k = 0; k &lt; n-3; k++){ for(int i = k + 1; i &lt; n-2; i++){ int left = i + 1, right = n - 1; int ret = target - nums[k] - nums[i]; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; ret){ right–; }else if(temp &lt; ret){ left++; }else{ vector tmp{nums[k], nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } while(k + 1 &lt; n -3 &amp;&amp; nums[k] == nums[k + 1]) k++; } return res; }}; Container With Most Water Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.题目要求：给定n个非负整数a1, a2, …, an, 每个都代表坐标轴上的高，其坐标为（i,ai）。可以根据这条数组构建一幅柱形图，每任意两条柱子形成一个水桶，要求找到能盛最多水的水桶的面积。题目分析：两条垂直的线和X轴组成一个容器，灌水多少不仅与两个柱子的高度有关，也与两个柱子的距离有关，公式：S(i,j) = min(ai, aj) * (j-i)，容器不能倾斜，求容纳最多水的两个线组合。定义left和right两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离题目解答：class Solution {public: int maxArea(vector&amp; height) { int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right){ int temp = min(height[right], height[left]); res = max(res, temp*(right - left)); if(height[right] &lt; height[left]) right–; else left++; } return res; }}; Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.题目要求：给定一个数组，每个元素表示海报高度，每个元素宽度均为 1 ，求这个数组能装多少雨水。题目分析：看一种只需要遍历一次即可的解法，这个算法需要left和right两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至left和right指针重合。题目解答：class Solution {public: int trap(vector&amp; height) { int res = 0, left = 0, right = height.size() - 1; int maxleft = 0, maxright = 0; while(left &lt; right){ if(height[left] &lt; height[right]){ if(height[left] &gt; maxleft){ maxleft = height[left]; }else{ res += maxleft - height[left]; } left++; }else{ if(height[right] &gt; maxright){ maxright = height[right]; }else{ res += maxright - height[right]; } right–; } } return res; }};(二)双指针之快慢指针相关题目： Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.题目要求：这道题让我们移除一个数组中和给定值相同的数字，并返回新的数组的长度。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不满足指定的值，slow指针前进一步，这样不满足条件的整数都被移动到数组的前面。题目解答：class Solution {public: int removeElement(vector&amp; nums, int val) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != val) nums[slow++] = nums[fast]; fast++; } return slow; }}; Move Zeroes Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.题目要求：这道题让我们将一个给定数组中所有的0都移到后面，把非零数前移，要求不能改变非零数的相对应的位置关系，而且不能拷贝额外的数组。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不等于0，slow指针前进一步，这样不等于0的整数都被移动到数组的前面。题目解答：class Solution {public: void moveZeroes(vector&amp; nums) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != 0) swap(nums[slow++], nums[fast]); fast++; } }}; Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.题目要求：这道题要我们从有序数组中去除重复项。题目分析：这道题的解题思路是，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第2个数字，如果快指针指向的数等于慢指针的前1个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 1, fast = 1, n = nums.size(); if(n &lt;= 1) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 1]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.题目要求：这道题要我们从有序数组中去除重复项，每个数最多重复出现2次。题目分析：与上一道解题思路相似，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第3个数字，如果快指针指向的数等于慢指针的前2个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 2, fast = 2, n = nums.size(); if(n &lt;= 2) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 2]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.题目要求：在一个长度为n+1的数组中，每个数都是1-n之间，只有一个数出现两次，其他的数都只出现过一次，请找出这个数。题目分析：核心思想快慢指针，由于题目限定了区间[1,n]，所以可以巧妙的利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，我们用快慢指针可以找到环并确定环的起始位置，确实是太巧妙了！题目解答：class Solution {public: int findDuplicate(vector&amp; nums) { int slow = nums[0], fast = nums[nums[0]]; while(slow != fast){ slow = nums[slow]; fast = nums[nums[fast]]; } fast = 0; while(slow != fast){ slow = nums[slow]; fast = nums[fast]; } return slow; }};(三)双指针之后序指针相关题目： Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.题目要求：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1中，使得 num1 成为一个有序数组。你可以假设 nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。在 nums1 和 nums2 中初始化的元素的数量分别是 m 和 n。题目分析：算法思想是：由于合并后A数组的大小必定是m+n，所以从最后面开始往前赋值，先比较A和B中最后一个元素的大小，把较大的那个插入到m+n-1的位置上，再依次向前推。如果A中所有的元素都比B小，那么前m个还是A原来的内容，没有改变。如果A中的数组比B大的，当A循环完了，B中还有元素没加入A，直接用个循环把B中所有的元素覆盖到A剩下的位置。题目解答：class Solution {public: void merge(vector&amp; nums1, int m, vector&amp; nums2, int n) { int i = m - 1, j = n - 1, k = m + n -1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ if(nums1[i] &gt; nums2[j]) nums1[k–] = nums1[i–]; else nums1[k–] = nums2[j–]; } while(j &gt;= 0) nums1[k–] = nums2[j–]; }","categories":[],"tags":[]},{"title":"","slug":"二叉树","date":"2019-06-13T02:29:21.353Z","updated":"2019-06-13T02:29:21.532Z","comments":true,"path":"2019/06/13/二叉树/","link":"","permalink":"http://yoursite.com/2019/06/13/二叉树/","excerpt":"","text":"二叉树是一种非常重要的数据结构，非常多其他数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们寻常所说的层次遍历。由于树的定义本身就是递归定义，因此採用递归的方法去实现树的三种遍历不仅easy理解并且代码非常简洁，而对于广度遍历来说，须要其他数据结构的支撑。比方堆了。所以。对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。 四种基本的遍历思想为： 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树 中序遍历：左子树—&gt; 根结点 —&gt; 右子树 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点 层次遍历：仅仅需按层次遍历就可以 比如。求以下二叉树的各种遍历 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 一、前序遍历 1）依据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，非常easy写出递归版本号： public void preOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ System.out.print(root.val+” “); ​ preOrderTraverse1(root.left); ​ preOrderTraverse1(root.right); ​ } ​ } 2）如今讨论非递归的版本号： 依据前序遍历的顺序，优先訪问根结点。然后在訪问左子树和右子树。所以。对于随意结点node。第一部分即直接訪问之，之后在推断左子树是否为空，不为空时即反复上面的步骤，直到其为空。若为空。则须要訪问右子树。注意。在訪问过左孩子之后。须要反过来訪问其右孩子。所以，须要栈这样的数据结构的支持。对于随意一个结点node，详细过程例如以下： a)訪问之，并把结点node入栈。当前结点置为左孩子； b)推断结点node是否为空，若为空。则取出栈顶结点并出栈，将右孩子置为当前结点；否则反复a)步直到当前结点为空或者栈为空（能够发现栈中的结点就是为了訪问右孩子才存储的） 代码例如以下： public void preOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ System.out.print(pNode.val+” “); ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ pNode = node.right; ​ } ​ } ​ } 二、中序遍历 1)依据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，非常easy写出递归版本号： public void inOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ inOrderTraverse1(root.left); ​ System.out.print(root.val+” “); ​ inOrderTraverse1(root.right); ​ } ​ } 2）非递归实现，有了上面前序的解释，中序也就比較简单了。同样的道理。仅仅只是訪问的顺序移到出栈时。代码例如以下： public void inOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ pNode = node.right; ​ } ​ } ​ } 三、后序遍历 1）依据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点。非常easy写出递归版本号： public void postOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ postOrderTraverse1(root.left); ​ postOrderTraverse1(root.right); ​ System.out.print(root.val+” “); ​ } ​ } 2） 后序遍历的非递归实现是三种遍历方式中最难的一种。由于在后序遍历中，要保证左孩子和右孩子都已被訪问而且左孩子在右孩子前訪问才干訪问根结点，这就为流程的控制带来了难题。以下介绍两种思路。 ​ 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索。直到搜索到没有左孩子的结点，此时该结点出如今栈顶，可是此时不能将其出栈并訪问，因此其右孩子还为被訪问。 所以接下来依照同样的规则对其右子树进行同样的处理，当訪问完其右孩子时。该结点又出如今栈顶，此时能够将其出栈并訪问。这样就保证了正确的訪问顺序。能够看出，在这个过程中，每一个结点都两次出如今栈顶，仅仅有在第二次出如今栈顶时，才干訪问它。因此须要多设置一个变量标识该结点是否是第一次出如今栈顶。 123456789101112131415161718192021222324252627282930313233void postOrder2(BinTree *root) //非递归后序遍历&#123; stack&lt;BTNode*&gt; s; BinTree *p=root; BTNode *temp; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) //沿左子树一直往下搜索。直至出现没有左子树的结点 &#123; BTNode *btn=(BTNode *)malloc(sizeof(BTNode)); btn-&gt;btnode=p; btn-&gt;isFirst=true; s.push(btn); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; temp=s.top(); s.pop(); if(temp-&gt;isFirst==true) //表示是第一次出如今栈顶 &#123; temp-&gt;isFirst=false; s.push(temp); p=temp-&gt;btnode-&gt;rchild; &#125; else //第二次出如今栈顶 &#123; cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;; p=NULL; &#125; &#125; &#125; &#125; ​ 另外一种思路：要保证根结点在左孩子和右孩子訪问之后才干訪问，因此对于任一结点P。先将其入栈。假设P不存在左孩子和右孩子。则能够直接訪问它；或者P存在左孩子或者右孩子。可是其左孩子和右孩子都已被訪问过了。则相同能够直接訪问该结点。若非上述两种情况。则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被訪问。左孩子和右孩子都在根结点前面被訪问。 12345678910111213141516171819202122232425void postOrder3(BinTree *root) //非递归后序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *cur; //当前结点 BinTree *pre=NULL; //前一次訪问的结点 s.push(root); while(!s.empty()) &#123; cur=s.top(); if((cur-&gt;lchild==NULL&amp;&amp;cur-&gt;rchild==NULL)|| (pre!=NULL&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild))) &#123; cout&lt;&lt;cur-&gt;data&lt;&lt;&quot; &quot;; //假设当前结点没有孩子结点或者孩子节点都已被訪问过 s.pop(); pre=cur; &#125; else &#123; if(cur-&gt;rchild!=NULL) s.push(cur-&gt;rchild); if(cur-&gt;lchild!=NULL) s.push(cur-&gt;lchild); &#125; &#125; &#125; 四、层次遍历 层次遍历的代码比較简单。仅仅须要一个队列就可以。先在队列中增加根结点。之后对于随意一个结点来说。在其出队列的时候，訪问之。同一时候假设左孩子和右孩子有不为空的。入队列。代码例如以下： public void levelTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList queue = new LinkedList&lt;&gt;(); ​ queue.offer(root); ​ while (!queue.isEmpty()) { ​ TreeNode node = queue.poll(); ​ System.out.print(node.val+” “); ​ if (node.left != null) { ​ queue.offer(node.left); ​ } ​ if (node.right != null) { ​ queue.offer(node.right); ​ } ​ } ​ } 五、深度优先遍历 事实上深度遍历就是上面的前序、中序和后序。可是为了保证与广度优先遍历相照顾，也写在这。代码也比較好理解，事实上就是前序遍历，代码例如以下： [java] view plain copy public void depthOrderTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ stack.push(root); ​ while (!stack.isEmpty()) { ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ if (node.right != null) { ​ stack.push(node.right); ​ } ​ if (node.left != null) { ​ stack.push(node.left); ​ } ​ } ​ }","categories":[],"tags":[]},{"title":"Image","slug":"images","date":"2019-05-24T08:47:12.411Z","updated":"2019-05-24T09:10:40.928Z","comments":true,"path":"2019/05/24/images/","link":"","permalink":"http://yoursite.com/2019/05/24/images/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDBC学习","slug":"笔记（一） - 副本","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:20:09.849Z","comments":true,"path":"2019/05/24/笔记（一） - 副本/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一） - 副本/","excerpt":"","text":"事务&amp;数据库连接池&amp;DBUtils事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库rollback ; 数据回滚，回到最初的状态。 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); 12345678910111213141516171819@Testpublic void testTransaction()&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); ​ 总结事务123使用命令行演示使用代码演示 脏读、 不可重复读、 幻读丢失更新 12345678悲观锁乐观锁4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 12queryRunner.update();queryRunner.query","categories":[],"tags":[]},{"title":"Hexo学习（一）","slug":"笔记（一）","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:19:19.405Z","comments":true,"path":"2019/05/24/笔记（一）/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一）/","excerpt":"","text":"Hexo学习（一）此文介绍Hexo建站的流程…特别鸣谢 指导人 CodeSheep 从此打开新的大门let‘s go 01.安装 Node.j打开官方网站 https://nodejs.org 02.安装 Git打开官方网站 https://git-scm.com/downloads 然后我们选择windows版本的下载 安装也是一直点下一步，安装官方默认的来就行，完了，在开始菜单可以看到 tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。 03.安装hexo新建一个文件夹，比如我这里建了 ==blog4==打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==看看 ==node，npm== 是否安装成功，没有成功的就重新安装node。 我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm在上面终端继续输入npm install -g cnpm --registry=https://registry.npm.taobao.org测试cnpm-成功！ ==完成之后安装hexo==cnpm install -g hexo-cli 验证是否安装成功hexo -v出现,说明成功 1234567891011121314151617hexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.3v8: 6.8.275.32-node.51uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 首先看看当前路径命令pwd结果为Administrator@XTZ-01804162214 MINGW64 ~/Desktop/blog4然后我们运行命令，这步是关键，主要是建立整个项目，这里我的文件夹名字是kuku，文件夹位置是桌面上。hexo init结果如下： 04.运行测试这里我们经常用到的有三个命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 我们运行hexo s 打开浏览器，输入localhost:4000,看到 说明本地环境搭建完成。。。其余的内容请看下一篇文章。","categories":[],"tags":[]}]}