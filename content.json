{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"欢迎大家!!","date":"2019-05-24T09:29:49.538Z","updated":"2019-05-24T09:29:49.538Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"真正的才智是刚毅的志向。 —— 拿破仑感情有着极大的鼓舞力量，因此，它是一切道德行为的重要前提，谁要是没有强烈的志向，也就不能够热烈地把这个志向体现于事业中。 —— 凯洛夫勇敢坚毅真正之才智乃刚毅之志向。 —— 拿破仑生活赋予我们一种巨大的和无限高贵的礼品，这就是青春：充满着力量，充满着期待志愿，充满着求知和斗争的志向，充满着希望信心和青春。 —— 奥斯特洛夫斯基志向不过是记忆的奴隶，生气勃勃地降生，但却很难成长。 —— 莎士比亚"}],"posts":[{"title":"双指针题","slug":"双指针","date":"2019-06-13T05:46:16.000Z","updated":"2019-06-13T02:31:36.987Z","comments":true,"path":"2019/06/13/双指针/","link":"","permalink":"http://yoursite.com/2019/06/13/双指针/","excerpt":"","text":"双指针(Two Pointers)一直是程序员面试中的一个必须准备的主题， 面试中双指针出现的次数比较多，主要由于在工作中指针经常用到，指针问题能够直接反应面试者的基础知识、代码能力和思维逻辑，因此双指针的问题必须掌握。 解决双指针问题三种常用思想： 左右指针：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇快慢指针：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾后序指针：常规指针操作是从前向后便利，对于合并和替换类型题，防止之前的数据被覆盖，双指针需从后向前便利记忆口诀：左右指针中间夹，快慢指针走到头，后序指针往回走LeetCode中关于双指针的题目有以下三种类型题： (一)双指针之左右指针相关题目： (二)双指针之快慢指针相关题目： (三)双指针之后序指针相关题目： (一)双指针之左右指针相关题目： Two Sum II - Input array is sorted Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2题目要求：给定一个升序排列的整数数组，找到两个数，使它们的和等于给定的数，有且仅有一个满足条件的解，返回索引。题目分析：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止。题目解答：class Solution {public: vector twoSum(vector&amp; numbers, int target) { vector res(2, -1); int left = 0, right = numbers.size() - 1; while(left &lt; right){ int temp = numbers[left] + numbers[right]; if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ res[0] = left + 1; res[1] = right + 1; return res; } } return res; }}; 3Sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，满足a + b + c = 0？ 找到数组中所有的三元组。注意：解决方案中不得包含重复的三元组。题目分析：尝试把三数和问题转化为两数和问题：同样先对数组排序，设置三个指针i,left,right，i指针指向第一个数x，则left,right要指向数组中剩余数中的两个，并且指向的两数和为-x，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; threeSum(vector&amp; nums) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 2) return res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; -nums[i]){ right–; }else if(temp &lt; -nums[i]){ left++; }else{ vector tmp{nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 3Sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.题目要求：这道题让我们求最接近给定值的三数之和。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量small用来记录差的绝对值。题目解答：class Solution {public: int threeSumClosest(vector&amp; nums, int target) { int n = nums.size(), res = INT_MIN, small = INT_MAX; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; n-2; i++){ int left = i + 1, right = n - 1; while(left &lt; right){ int temp = nums[left] + nums[right] + nums[i]; if(abs(temp - target) &lt; small){ res = temp; small = abs(temp - target); } if(temp &gt; target){ right–; }else if(temp &lt; target){ left++; }else{ return target; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } return res; }}; 4Sum Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.题目要求：给定n个整数的数组nums，nums中是否有元素a，b，c，d 满足a + b + c + d= target？ 找到数组中所有的四元组。注意：解决方案中不得包含重复的四元组。题目分析：在上一道的15. 3Sum基础上又增加了些许难度，尝试把四数和问题转化为两数和问题：同样先对数组排序，设置四个指针k,i,left,right，k指针指向第一个数，i指针指向第二个数,则left,right要指向数组中剩余数中的两个，从而转化为两数和问题。题目解答：class Solution {public: vector&lt;vector&gt; fourSum(vector&amp; nums, int target) { vector&lt;vector&gt; res; int n = nums.size(); if(n &lt;= 3) return res; sort(nums.begin(), nums.end()); for(int k = 0; k &lt; n-3; k++){ for(int i = k + 1; i &lt; n-2; i++){ int left = i + 1, right = n - 1; int ret = target - nums[k] - nums[i]; while(left &lt; right){ int temp = nums[left] + nums[right]; if(temp &gt; ret){ right–; }else if(temp &lt; ret){ left++; }else{ vector tmp{nums[k], nums[i], nums[left], nums[right]}; res.push_back(tmp); left++; right–; while(left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++; while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right–; } } while(i + 1 &lt; n -2 &amp;&amp; nums[i] == nums[i + 1]) i++; } while(k + 1 &lt; n -3 &amp;&amp; nums[k] == nums[k + 1]) k++; } return res; }}; Container With Most Water Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.题目要求：给定n个非负整数a1, a2, …, an, 每个都代表坐标轴上的高，其坐标为（i,ai）。可以根据这条数组构建一幅柱形图，每任意两条柱子形成一个水桶，要求找到能盛最多水的水桶的面积。题目分析：两条垂直的线和X轴组成一个容器，灌水多少不仅与两个柱子的高度有关，也与两个柱子的距离有关，公式：S(i,j) = min(ai, aj) * (j-i)，容器不能倾斜，求容纳最多水的两个线组合。定义left和right两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离题目解答：class Solution {public: int maxArea(vector&amp; height) { int left = 0, right = height.size() - 1; int res = 0; while(left &lt; right){ int temp = min(height[right], height[left]); res = max(res, temp*(right - left)); if(height[right] &lt; height[left]) right–; else left++; } return res; }}; Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.题目要求：给定一个数组，每个元素表示海报高度，每个元素宽度均为 1 ，求这个数组能装多少雨水。题目分析：看一种只需要遍历一次即可的解法，这个算法需要left和right两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至left和right指针重合。题目解答：class Solution {public: int trap(vector&amp; height) { int res = 0, left = 0, right = height.size() - 1; int maxleft = 0, maxright = 0; while(left &lt; right){ if(height[left] &lt; height[right]){ if(height[left] &gt; maxleft){ maxleft = height[left]; }else{ res += maxleft - height[left]; } left++; }else{ if(height[right] &gt; maxright){ maxright = height[right]; }else{ res += maxright - height[right]; } right–; } } return res; }};(二)双指针之快慢指针相关题目： Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.题目要求：这道题让我们移除一个数组中和给定值相同的数字，并返回新的数组的长度。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不满足指定的值，slow指针前进一步，这样不满足条件的整数都被移动到数组的前面。题目解答：class Solution {public: int removeElement(vector&amp; nums, int val) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != val) nums[slow++] = nums[fast]; fast++; } return slow; }}; Move Zeroes Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.题目要求：这道题让我们将一个给定数组中所有的0都移到后面，把非零数前移，要求不能改变非零数的相对应的位置关系，而且不能拷贝额外的数组。题目分析：使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不等于0，slow指针前进一步，这样不等于0的整数都被移动到数组的前面。题目解答：class Solution {public: void moveZeroes(vector&amp; nums) { int slow = 0, fast = 0, n = nums.size(); while(fast &lt; n){ if(nums[fast] != 0) swap(nums[slow++], nums[fast]); fast++; } }}; Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.题目要求：这道题要我们从有序数组中去除重复项。题目分析：这道题的解题思路是，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第2个数字，如果快指针指向的数等于慢指针的前1个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 1, fast = 1, n = nums.size(); if(n &lt;= 1) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 1]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Remove Duplicates from Sorted Array II Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.题目要求：这道题要我们从有序数组中去除重复项，每个数最多重复出现2次。题目分析：与上一道解题思路相似，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第3个数字，如果快指针指向的数等于慢指针的前2个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。题目解答：class Solution {public: int removeDuplicates(vector&amp; nums) { int slow = 2, fast = 2, n = nums.size(); if(n &lt;= 2) return n; while(fast &lt; n){ if(nums[fast] != nums[slow - 2]) nums[slow++] = nums[fast]; fast++; } return slow; }}; Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n(inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.题目要求：在一个长度为n+1的数组中，每个数都是1-n之间，只有一个数出现两次，其他的数都只出现过一次，请找出这个数。题目分析：核心思想快慢指针，由于题目限定了区间[1,n]，所以可以巧妙的利用坐标和数值之间相互转换，而由于重复数字的存在，那么一定会形成环，我们用快慢指针可以找到环并确定环的起始位置，确实是太巧妙了！题目解答：class Solution {public: int findDuplicate(vector&amp; nums) { int slow = nums[0], fast = nums[nums[0]]; while(slow != fast){ slow = nums[slow]; fast = nums[nums[fast]]; } fast = 0; while(slow != fast){ slow = nums[slow]; fast = nums[fast]; } return slow; }};(三)双指针之后序指针相关题目： Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.题目要求：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1中，使得 num1 成为一个有序数组。你可以假设 nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。在 nums1 和 nums2 中初始化的元素的数量分别是 m 和 n。题目分析：算法思想是：由于合并后A数组的大小必定是m+n，所以从最后面开始往前赋值，先比较A和B中最后一个元素的大小，把较大的那个插入到m+n-1的位置上，再依次向前推。如果A中所有的元素都比B小，那么前m个还是A原来的内容，没有改变。如果A中的数组比B大的，当A循环完了，B中还有元素没加入A，直接用个循环把B中所有的元素覆盖到A剩下的位置。题目解答：class Solution {public: void merge(vector&amp; nums1, int m, vector&amp; nums2, int n) { int i = m - 1, j = n - 1, k = m + n -1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ if(nums1[i] &gt; nums2[j]) nums1[k–] = nums1[i–]; else nums1[k–] = nums2[j–]; } while(j &gt;= 0) nums1[k–] = nums2[j–]; }","categories":[],"tags":[]},{"title":"","slug":"二叉树","date":"2019-06-13T02:29:21.353Z","updated":"2019-06-13T02:29:21.532Z","comments":true,"path":"2019/06/13/二叉树/","link":"","permalink":"http://yoursite.com/2019/06/13/二叉树/","excerpt":"","text":"二叉树是一种非常重要的数据结构，非常多其他数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们寻常所说的层次遍历。由于树的定义本身就是递归定义，因此採用递归的方法去实现树的三种遍历不仅easy理解并且代码非常简洁，而对于广度遍历来说，须要其他数据结构的支撑。比方堆了。所以。对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。 四种基本的遍历思想为： 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树 中序遍历：左子树—&gt; 根结点 —&gt; 右子树 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点 层次遍历：仅仅需按层次遍历就可以 比如。求以下二叉树的各种遍历 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 一、前序遍历 1）依据上文提到的遍历思路：根结点 —&gt; 左子树 —&gt; 右子树，非常easy写出递归版本号： public void preOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ System.out.print(root.val+” “); ​ preOrderTraverse1(root.left); ​ preOrderTraverse1(root.right); ​ } ​ } 2）如今讨论非递归的版本号： 依据前序遍历的顺序，优先訪问根结点。然后在訪问左子树和右子树。所以。对于随意结点node。第一部分即直接訪问之，之后在推断左子树是否为空，不为空时即反复上面的步骤，直到其为空。若为空。则须要訪问右子树。注意。在訪问过左孩子之后。须要反过来訪问其右孩子。所以，须要栈这样的数据结构的支持。对于随意一个结点node，详细过程例如以下： a)訪问之，并把结点node入栈。当前结点置为左孩子； b)推断结点node是否为空，若为空。则取出栈顶结点并出栈，将右孩子置为当前结点；否则反复a)步直到当前结点为空或者栈为空（能够发现栈中的结点就是为了訪问右孩子才存储的） 代码例如以下： public void preOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ System.out.print(pNode.val+” “); ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ pNode = node.right; ​ } ​ } ​ } 二、中序遍历 1)依据上文提到的遍历思路：左子树 —&gt; 根结点 —&gt; 右子树，非常easy写出递归版本号： public void inOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ inOrderTraverse1(root.left); ​ System.out.print(root.val+” “); ​ inOrderTraverse1(root.right); ​ } ​ } 2）非递归实现，有了上面前序的解释，中序也就比較简单了。同样的道理。仅仅只是訪问的顺序移到出栈时。代码例如以下： public void inOrderTraverse2(TreeNode root) { ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ TreeNode pNode = root; ​ while (pNode != null || !stack.isEmpty()) { ​ if (pNode != null) { ​ stack.push(pNode); ​ pNode = pNode.left; ​ } else { //pNode == null &amp;&amp; !stack.isEmpty() ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ pNode = node.right; ​ } ​ } ​ } 三、后序遍历 1）依据上文提到的遍历思路：左子树 —&gt; 右子树 —&gt; 根结点。非常easy写出递归版本号： public void postOrderTraverse1(TreeNode root) { ​ if (root != null) { ​ postOrderTraverse1(root.left); ​ postOrderTraverse1(root.right); ​ System.out.print(root.val+” “); ​ } ​ } 2） 后序遍历的非递归实现是三种遍历方式中最难的一种。由于在后序遍历中，要保证左孩子和右孩子都已被訪问而且左孩子在右孩子前訪问才干訪问根结点，这就为流程的控制带来了难题。以下介绍两种思路。 ​ 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索。直到搜索到没有左孩子的结点，此时该结点出如今栈顶，可是此时不能将其出栈并訪问，因此其右孩子还为被訪问。 所以接下来依照同样的规则对其右子树进行同样的处理，当訪问完其右孩子时。该结点又出如今栈顶，此时能够将其出栈并訪问。这样就保证了正确的訪问顺序。能够看出，在这个过程中，每一个结点都两次出如今栈顶，仅仅有在第二次出如今栈顶时，才干訪问它。因此须要多设置一个变量标识该结点是否是第一次出如今栈顶。 123456789101112131415161718192021222324252627282930313233void postOrder2(BinTree *root) //非递归后序遍历&#123; stack&lt;BTNode*&gt; s; BinTree *p=root; BTNode *temp; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) //沿左子树一直往下搜索。直至出现没有左子树的结点 &#123; BTNode *btn=(BTNode *)malloc(sizeof(BTNode)); btn-&gt;btnode=p; btn-&gt;isFirst=true; s.push(btn); p=p-&gt;lchild; &#125; if(!s.empty()) &#123; temp=s.top(); s.pop(); if(temp-&gt;isFirst==true) //表示是第一次出如今栈顶 &#123; temp-&gt;isFirst=false; s.push(temp); p=temp-&gt;btnode-&gt;rchild; &#125; else //第二次出如今栈顶 &#123; cout&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;&quot; &quot;; p=NULL; &#125; &#125; &#125; &#125; ​ 另外一种思路：要保证根结点在左孩子和右孩子訪问之后才干訪问，因此对于任一结点P。先将其入栈。假设P不存在左孩子和右孩子。则能够直接訪问它；或者P存在左孩子或者右孩子。可是其左孩子和右孩子都已被訪问过了。则相同能够直接訪问该结点。若非上述两种情况。则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被訪问。左孩子和右孩子都在根结点前面被訪问。 12345678910111213141516171819202122232425void postOrder3(BinTree *root) //非递归后序遍历&#123; stack&lt;BinTree*&gt; s; BinTree *cur; //当前结点 BinTree *pre=NULL; //前一次訪问的结点 s.push(root); while(!s.empty()) &#123; cur=s.top(); if((cur-&gt;lchild==NULL&amp;&amp;cur-&gt;rchild==NULL)|| (pre!=NULL&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild))) &#123; cout&lt;&lt;cur-&gt;data&lt;&lt;&quot; &quot;; //假设当前结点没有孩子结点或者孩子节点都已被訪问过 s.pop(); pre=cur; &#125; else &#123; if(cur-&gt;rchild!=NULL) s.push(cur-&gt;rchild); if(cur-&gt;lchild!=NULL) s.push(cur-&gt;lchild); &#125; &#125; &#125; 四、层次遍历 层次遍历的代码比較简单。仅仅须要一个队列就可以。先在队列中增加根结点。之后对于随意一个结点来说。在其出队列的时候，訪问之。同一时候假设左孩子和右孩子有不为空的。入队列。代码例如以下： public void levelTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList queue = new LinkedList&lt;&gt;(); ​ queue.offer(root); ​ while (!queue.isEmpty()) { ​ TreeNode node = queue.poll(); ​ System.out.print(node.val+” “); ​ if (node.left != null) { ​ queue.offer(node.left); ​ } ​ if (node.right != null) { ​ queue.offer(node.right); ​ } ​ } ​ } 五、深度优先遍历 事实上深度遍历就是上面的前序、中序和后序。可是为了保证与广度优先遍历相照顾，也写在这。代码也比較好理解，事实上就是前序遍历，代码例如以下： [java] view plain copy public void depthOrderTraverse(TreeNode root) { ​ if (root == null) { ​ return; ​ } ​ LinkedList stack = new LinkedList&lt;&gt;(); ​ stack.push(root); ​ while (!stack.isEmpty()) { ​ TreeNode node = stack.pop(); ​ System.out.print(node.val+” “); ​ if (node.right != null) { ​ stack.push(node.right); ​ } ​ if (node.left != null) { ​ stack.push(node.left); ​ } ​ } ​ }","categories":[],"tags":[]},{"title":"Image","slug":"images","date":"2019-05-24T08:47:12.411Z","updated":"2019-05-24T09:10:40.928Z","comments":true,"path":"2019/05/24/images/","link":"","permalink":"http://yoursite.com/2019/05/24/images/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"java静态代理与动态代理","slug":"代理设计模式","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:30:57.674Z","comments":true,"path":"2019/05/24/代理设计模式/","link":"","permalink":"http://yoursite.com/2019/05/24/代理设计模式/","excerpt":"","text":"代理模式简介代理模式（proxy）指的是为一个对象提供一个代理以控制外界对该对象的访问，比如有些情况下对象A不能直接访问对象B，此时可以为对象B创建一个代理C，然后对象A通过访问代理C来间接访问对象B。比如你看上了你女性朋友的闺蜜，此时你可以通过你的朋友来跟她闺蜜进行一些沟通。有的时候我们希望增强某个方法的功能，但是有不方便直接修改该方法，此时也可通过代理来实现，即在该方法执行的前后做一些事情。比如你要打官司，但是法律上的事情你可能不清楚，此时需要请一名代理律师，让这个代理律师帮助你去做一些事情。 代理的模式的优点： 提高程序的扩展性和可复用性 保护目标对象 代理模式分为两种：静态代理和动态代理。 静态代理代理类和相关的方法直接在代码中写死。下面以你看上了你女性朋友娜娜的闺蜜小曼举例： 首先定义一个接口： 1234567891011package com.monkey1024.proxy.staticproxy;/** * 女神 */public interface Beauty &#123; void eat();&#125; 创建小曼的类并实现上面的接口： 12345678910111213package com.monkey1024.proxy.staticproxy;/** * 你的目标对象小曼 * 你女性朋友娜娜的闺蜜 */public class XiaoMan implements Beauty &#123; @Override public void eat() &#123; System.out.println(&quot;小曼吃饭&quot;); &#125;&#125; 创建娜娜的类实现上面接口，娜娜是中间人，所以实现方式不太一样，这里的eat方法中要调用目标对象上的eat方法： 123456789101112131415161718192021222324package com.monkey1024.proxy.staticproxy;/** * 中间人，你的女性朋友娜娜 */public class NaNa implements Beauty &#123; private Beauty beauty; /** * 通过构造方法传入目标对象 * @param beauty */ public NaNa(Beauty beauty) &#123; this.beauty = beauty; &#125; @Override public void eat() &#123; //调用目标对象上的吃饭方法 beauty.eat(); &#125;&#125; 创建你的类，里面添加交朋友的方法： 1234567891011121314151617package com.monkey1024.proxy.staticproxy;public class You &#123; private Beauty beauty; public You(Beauty beauty) &#123; this.beauty = beauty; &#125; /** * 交朋友 */ public void makeFriend() &#123; beauty.eat(); &#125;&#125; 创建测试类： 12345678910111213package com.monkey1024.proxy.staticproxy;public class Test &#123; public static void main(String[] args) &#123; XiaoMan xiaoMan = new XiaoMan(); NaNa naNa = new NaNa(xiaoMan); You you = new You(naNa); you.makeFriend(); &#125;&#125; 动态代理动态代理它可以直接给某一个目标对象生成一个代理对象，而不需要代理类存在。动态代理与静态代理原理是一样的，只是它没有具体的代理类，直接在程序运行时动态生成了一个代理对象。 动态代理的技术实现： JDK提供的动态代理，底层使用反射原理，只能创建接口的代理。 cglib，底层是通过使用一个小而快的字节码处理框架ASM，可以创建类和接口的代理。 jdk的动态代理： Proxy.newProxyInstance():产生代理接口的实例。仅能代理实现至少一个接口的类 ClassLoader：类加载器。即被代理的接口的类加载器。 Class[] interface：被代理对象的父接口 InvocationHandler：将要在代理中实现的功能写在该对象中 InvocationHandler中的invoke方法：调用代理类的任何方法，此方法都会执行 Object proxy:代理对象自身的引用。 Method method:当前被调用的方法。 Object[] args:当前被调用方法用到的参数 只需要将之前的测试类中的代码修改为下面的内容即可： 12345678910111213141516171819202122232425262728293031package com.monkey1024.proxy.staticproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; Beauty xiaoMan = new XiaoMan(); //不需要自己创建代理了 //NaNa naNa = new NaNa(xiaoMan); //由jdk动态的为你创建一个代理 Beauty proxy = (Beauty)Proxy.newProxyInstance(xiaoMan.getClass().getClassLoader(), xiaoMan.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;吃饭之前的准备&quot;); Object invoke = method.invoke(xiaoMan); System.out.println(&quot;吃饭之后的结果&quot;); return invoke; &#125; &#125;); You you = new You(proxy); you.makeFriend(); &#125;&#125; 调用有参数的方法在彼此认识之后，你打算送小曼礼物，此时将之前的代码稍作修改： 在接口中新增gift方法，count表示礼物的数量： 1void gift(int count); 在XiaoMan的类中添加gift方法的重写： 1234@Overridepublic void gift(int count) &#123; System.out.println(&quot;收到&quot; + count + &quot;礼物&quot;);&#125; 在You类中添加show方法用来送礼物： 123456/** * 展示 */public void show()&#123; beauty.gift(10);&#125; 修改之前的测试类如下，送礼物的时候，为了感谢代理人，所以每次会把礼物分一半给代理人： 1234567891011121314151617181920212223242526Beauty xiaoMan = new XiaoMan(); //不需要自己创建代理了 //NaNa naNa = new NaNa(xiaoMan); //由jdk动态的为你创建一个代理 Beauty proxy = (Beauty)Proxy.newProxyInstance(xiaoMan.getClass().getClassLoader(), xiaoMan.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;准备&quot;); Object invoke = null; if (&quot;gift&quot;.equals(method.getName()))&#123; invoke = method.invoke(xiaoMan,new Object[]&#123;(Integer)args[0]/2&#125;); &#125;else&#123; invoke = method.invoke(xiaoMan); &#125; System.out.println(&quot;结果&quot;); return invoke; &#125; &#125;); You you = new You(proxy); you.makeFriend(); you.show();","categories":[],"tags":[]},{"title":"工厂设计模式","slug":"工厂设计模式","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:39:28.259Z","comments":true,"path":"2019/05/24/工厂设计模式/","link":"","permalink":"http://yoursite.com/2019/05/24/工厂设计模式/","excerpt":"","text":"工厂模式简介工厂模式就是用工厂提供的方法代替了使用new创建对象的操作, 将创建对象统一管理和控制从而将调用者与实现类进行解耦，实现了创建者与调用者的分离。例如MyBatis中SqlSessionFactory创建SqlSession，这个就使用了工厂模式。工厂模式的分类： 简单工厂模式（静态工厂） 工厂方法模式 抽象工厂 简单工厂模式有的地方也叫作静态工厂，实际上它并不算是设计模式，只不过算是工厂方法和抽象工厂的基础，不过也有一些运用的地方。比如jdk的动态代理的Proxy.newProxyInstance这个就是一个简单工厂，另外Calendar.getInstance也是一个简单的工厂。比如你接到了生产苹果手机的订单，此时你需要建一个工厂去生产苹果手机，这里就生产iPhone X和iPhone 8 plus两款手机。 先创建一个iPhone手机的接口： 1234567/** * 苹果手机 */public interface IPhone &#123; void play();&#125; 创建IPhoneX系列手机 12345678910/** * iPhone X系列手机 */public class IPhoneX implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建iPhone 8 plus系列手机 12345678910/** * iPhone 8 Plus系列手机 */public class IPhone8Plus implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhone8Plus&quot;); &#125;&#125; 创建生产苹果手机的工厂： 123456789101112131415161718192021/** * iPhone工厂 */public class IPhoneFactory &#123; public static IPhone produce(String model)&#123; if (&quot;iPhoneX&quot;.equalsIgnoreCase(model)) &#123; //生产iPhoneX return new IPhoneX(); &#125; else if (&quot;iPhone8Plus&quot;.equalsIgnoreCase(model)) &#123; //生产iPhone 8 Plus return new IPhone8Plus(); &#125;else &#123; //不生产任何东西 return null; &#125; &#125;&#125; 创建测试类： 12345678public class Test01 &#123; public static void main(String[] args) &#123; //生产iPhone X手机 IPhone iPhone = IPhoneFactory.produce(&quot;iPhoneX&quot;); iPhone.play(); &#125;&#125; 静态工厂优点：通过以上代码可以看出来静态工厂的优点是封装了苹果手机创建的过程，对于使用者来说，直接调用工厂的方法就可以获取想要的手机了。 静态工厂缺点扩展性差，倘若要想再生产iPhone 8系列手机的话，需要修改的代码比较多。 工厂方法工厂方法模式的实质是定义一个用于创建对象的接口，然后让实现这个接口的类来决定创建哪个类的对象。这里还是以生产iPhone X和iPhone 8 plus手机为例。创建iphone接口： 1234public interface IPhone &#123; void play();&#125; 创建iPhone 8 plus手机： 1234567public class IPhone8Plus implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhone8Plus&quot;); &#125;&#125; 创建iPhone X手机： 1234567public class IPhoneX implements IPhone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建生产手机的大工厂： 12345678/** * iPhone大工厂 */public interface IPhoneFactory &#123; IPhone produce();&#125; 创建生产IPhoneX的工厂： 12345678910/** * 生产iphonex的工厂 */public class IPhoneXFactory implements IPhoneFactory &#123; @Override public IPhoneX produce() &#123; return new IPhoneX(); &#125;&#125; 创建生产iPhone 8 plus的工厂： 1234567public class IPhone8PlusFactory implements IPhoneFactory &#123; @Override public IPhone8Plus produce() &#123; return new IPhone8Plus(); &#125;&#125; 创建测试类： 12345678public class Test02 &#123; public static void main(String[] args) &#123; IPhone8PlusFactory iPhone8PlusFactory = new IPhone8PlusFactory(); IPhone8Plus iPhone8Plus = iPhone8PlusFactory.produce(); iPhone8Plus.play(); &#125;&#125; 工厂方法模式相对于静态工厂而言在虽然代码量多了一些，但是在程序的扩展性上要更好，倘若再加入生产iPhone 8手机的工厂，是不需要修改现有的工厂的。 抽象工厂抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。产品族就是一系列相关的产品，比如生产手机，还需要生产相应的充电器，手机和充电器就相当于是两个产品族，手机可以生产苹果手机、小米手机等，充电器可以生产苹果充电器、小米充电器等。 定义充电器的接口： 1234567/** * 充电器 */public interface Charger &#123; void charge();&#125; 定义手机的接口： 1234567/** * 手机 */public interface Telephone &#123; void play();&#125; 创建苹果手机充电器的类： 12345678910/** * 苹果手机充电器 */public class AppleCharger implements Charger &#123; @Override public void charge() &#123; System.out.println(&quot;给苹果手机充电&quot;); &#125;&#125; 创建小米手机充电器的类： 12345678910/** * 小米手机充电器 */public class XiaoMiCharger implements Charger &#123; @Override public void charge() &#123; System.out.println(&quot;给小米手机充电&quot;); &#125;&#125; 创建iPhone X手机的类： 12345678910/** * IPhoneX手机 */public class IPhoneX implements Telephone &#123; @Override public void play() &#123; System.out.println(&quot;IPhoneX&quot;); &#125;&#125; 创建小米8手机的类： 12345678910/** * XiaoMi8手机 */public class XiaoMi8 implements Telephone &#123; @Override public void play() &#123; System.out.println(&quot;小米8&quot;); &#125;&#125; 创建生产手机的大工厂： 1234567891011/** * 生产手机的大工厂 * * 要生产手机和相应的充电器 */public interface PhoneFactory &#123; Charger produceCharger(); Telephone producePhone();&#125; 创建生产iPhone X手机的工厂： 123456789101112131415/** * 生产苹果手机的工厂 */public class IPhoneXFactory implements PhoneFactory &#123; @Override public Charger produceCharger() &#123; return new AppleCharger(); &#125; @Override public Telephone producePhone() &#123; return new IPhoneX(); &#125;&#125; 创建生产小米8手机的工厂： 123456789101112public class XiaoMi8Factory implements PhoneFactory &#123; @Override public Charger produceCharger() &#123; return new XiaoMiCharger(); &#125; @Override public Telephone producePhone() &#123; return new XiaoMi8(); &#125;&#125; 创建测试类： 12345678910public class Test03 &#123; public static void main(String[] args) &#123; IPhoneXFactory iPhoneXFactory = new IPhoneXFactory(); Charger charger = iPhoneXFactory.produceCharger(); Telephone iPhoneX = iPhoneXFactory.producePhone(); charger.charge(); iPhoneX.play(); &#125;&#125; 工厂方法和抽象工厂的区别在于工厂方法的一个工厂只能创建一个具体产品。而抽象工厂的一个工厂可以创建属于一类类型的多种具体产品。 三种方式的总结静态工厂 ： 用来生产同一等级结构中的任意产品。产品的创建是由你传入参数决定的。 工厂方法 ：用来生产同一等级结构中的固定产品。一个工厂只能生产一个固定的产品。 抽象工厂 ：用来生产不同产品族的全部产品。一个工厂可以生产跟该产品相关的一系列产品。","categories":[],"tags":[]},{"title":"JDBC学习","slug":"笔记（一） - 副本","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:20:09.849Z","comments":true,"path":"2019/05/24/笔记（一） - 副本/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一） - 副本/","excerpt":"","text":"事务&amp;数据库连接池&amp;DBUtils事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库rollback ; 数据回滚，回到最初的状态。 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); 12345678910111213141516171819@Testpublic void testTransaction()&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); ​ 总结事务123使用命令行演示使用代码演示 脏读、 不可重复读、 幻读丢失更新 12345678悲观锁乐观锁4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 12queryRunner.update();queryRunner.query","categories":[],"tags":[]},{"title":"Hexo学习（一）","slug":"笔记（一）","date":"2019-05-24T05:46:16.000Z","updated":"2019-05-24T09:19:19.405Z","comments":true,"path":"2019/05/24/笔记（一）/","link":"","permalink":"http://yoursite.com/2019/05/24/笔记（一）/","excerpt":"","text":"Hexo学习（一）此文介绍Hexo建站的流程…特别鸣谢 指导人 CodeSheep 从此打开新的大门let‘s go 01.安装 Node.j打开官方网站 https://nodejs.org 02.安装 Git打开官方网站 https://git-scm.com/downloads 然后我们选择windows版本的下载 安装也是一直点下一步，安装官方默认的来就行，完了，在开始菜单可以看到 tips：这个Git Bash下载下来就相当于Linux中的终端窗口了，以后我们就用这个东东来打开终端。 03.安装hexo新建一个文件夹，比如我这里建了 ==blog4==打开你的文件夹，然后在空白处点鼠标的右键，选择 ==Git Bash Here==看看 ==node，npm== 是否安装成功，没有成功的就重新安装node。 我们需要先来安装个cnpm提高速度，以后下载什么东西都用cnpm在上面终端继续输入npm install -g cnpm --registry=https://registry.npm.taobao.org测试cnpm-成功！ ==完成之后安装hexo==cnpm install -g hexo-cli 验证是否安装成功hexo -v出现,说明成功 1234567891011121314151617hexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.3v8: 6.8.275.32-node.51uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 首先看看当前路径命令pwd结果为Administrator@XTZ-01804162214 MINGW64 ~/Desktop/blog4然后我们运行命令，这步是关键，主要是建立整个项目，这里我的文件夹名字是kuku，文件夹位置是桌面上。hexo init结果如下： 04.运行测试这里我们经常用到的有三个命令 1234hexo clean #用来清理缓存文件hexo g #生成文件hexo s #运行本地服务器hexo d #上传到服务器 我们运行hexo s 打开浏览器，输入localhost:4000,看到 说明本地环境搭建完成。。。其余的内容请看下一篇文章。","categories":[],"tags":[]},{"title":"Timer学习","slug":"Timer","date":"2019-05-24T05:46:16.000Z","updated":"2019-06-17T13:37:26.590Z","comments":true,"path":"2019/05/24/Timer/","link":"","permalink":"http://yoursite.com/2019/05/24/Timer/","excerpt":"","text":"一、简介​ 在java中一个完整定时任务需要由Timer、TimerTask两个类来配合完成。 API中是这样定义他们的，Timer：一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行。由TimerTask：Timer 安排为一次执行或重复执行的任务。我们可以这样理解Timer是一种定时器工具，用来在一个后台线程计划执行指定任务，而TimerTask一个抽象类，它的子类代表一个可以被Timer计划的任务。 Timer类​ 在工具类Timer中，提供了四个构造方法，每个构造方法都启动了计时器线程，同时Timer类可以保证多个线程可以共享单个Timer对象而无需进行外部同步，所以Timer类是线程安全的。但是由于每一个Timer对象对应的是单个后台线程，用于顺序执行所有的计时器任务，一般情况下我们的线程任务执行所消耗的时间应该非常短，但是由于特殊情况导致某个定时器任务执行的时间太长，那么他就会“独占”计时器的任务执行线程，其后的所有线程都必须等待它执行完，这就会延迟后续任务的执行，使这些任务堆积在一起，具体情况我们后面分析。 ​ 当程序初始化完成Timer后，定时任务就会按照我们设定的时间去执行，Timer提供了schedule方法，该方法有多中重载方式来适应不同的情况，如下： ​ schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务。 ​ schedule(TimerTask task, Date firstTime, long period) ：安排指定的任务在指定的时间开始进行重复的固定延迟执行。 ​ schedule(TimerTask task, long delay) ：安排在指定延迟后执行指定的任务。 ​ schedule(TimerTask task, long delay, long period) ：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。 ​ 同时也重载了scheduleAtFixedRate方法，scheduleAtFixedRate方法与schedule相同，只不过他们的侧重点不同，区别后面分析。 ​ scheduleAtFixedRate(TimerTask task, Date firstTime, long period)：安排指定的任务在指定的时间开始进行重复的固定速率执行。 ​ scheduleAtFixedRate(TimerTask task, long delay, long period)：安排指定的任务在指定的延迟后开始进行重复的固定速率执行。 TimerTask​ TimerTask类是一个抽象类，由Timer 安排为一次执行或重复执行的任务。它有一个抽象方法run()方法，该方法用于执行相应计时器任务要执行的操作。因此每一个具体的任务类都必须继承TimerTask，然后重写run()方法。 ​ 另外它还有两个非抽象的方法： ​ boolean cancel()：取消此计时器任务。 ​ long scheduledExecutionTime()：返回此任务最近实际执行的安排执行时间。 二、实例2.1、指定延迟时间执行定时任务[java] view plain copy public class TimerTest01 { ​ Timer timer; ​ public TimerTest01(int time){ ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest01(), time * 1000); ​ } ​ ​ public static void main(String[] args) { ​ System.out.println(“timer begin….”); ​ new TimerTest01(3); ​ } } public class TimerTaskTest01 extends TimerTask{ ​ public void run() { ​ System.out.println(“Time’s up!!!!”); ​ } } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class TimerTest01 &#123; Timer timer; public TimerTest01(int time)&#123; timer = new Timer(); timer.schedule(new TimerTaskTest01(), time * 1000); &#125; public static void main(String[] args) &#123; System.out.println(&quot;timer begin....&quot;); new TimerTest01(3); &#125;&#125; public class TimerTaskTest01 extends TimerTask&#123; public void run() &#123; System.out.println(&quot;Time&apos;s up!!!!&quot;); &#125;&#125; ​ 运行结果： 首先打印：timer begin…. 3秒后打印：Time’s up!!!! 123456789首先打印：timer begin.... 3秒后打印：Time&apos;s up!!!! 2.2、在指定时间执行定时任务[java] view plain copy public class TimerTest02 { ​ Timer timer; ​ ​ public TimerTest02(){ ​ Date time = getTime(); ​ System.out.println(“指定时间time=” + time); ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest02(), time); ​ } ​ ​ public Date getTime(){ ​ Calendar calendar = Calendar.getInstance(); ​ calendar.set(Calendar.HOUR_OF_DAY, 11); ​ calendar.set(Calendar.MINUTE, 39); ​ calendar.set(Calendar.SECOND, 00); ​ Date time = calendar.getTime(); ​ ​ return time; ​ } ​ ​ public static void main(String[] args) { ​ new TimerTest02(); ​ } } public class TimerTaskTest02 extends TimerTask{ ​ @Override ​ public void run() { ​ System.out.println(“指定时间执行线程任务…”); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class TimerTest02 &#123; Timer timer; public TimerTest02()&#123; Date time = getTime(); System.out.println(&quot;指定时间time=&quot; + time); timer = new Timer(); timer.schedule(new TimerTaskTest02(), time); &#125; public Date getTime()&#123; Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.HOUR_OF_DAY, 11); calendar.set(Calendar.MINUTE, 39); calendar.set(Calendar.SECOND, 00); Date time = calendar.getTime(); return time; &#125; public static void main(String[] args) &#123; new TimerTest02(); &#125;&#125; public class TimerTaskTest02 extends TimerTask&#123; @Override public void run() &#123; System.out.println(&quot;指定时间执行线程任务...&quot;); &#125;&#125; ​ 当时间到达11:39:00时就会执行该线程任务，当然大于该时间也会执行！！执行结果为： [java] view plain copy 指定时间time=Tue Jun 10 11:39:00 CST 2014 指定时间执行线程任务… 12345指定时间time=Tue Jun 10 11:39:00 CST 2014指定时间执行线程任务... 2.3、在延迟指定时间后以指定的间隔时间循环执行定时任务[java] view plain copy public class TimerTest03 { ​ Timer timer; ​ ​ public TimerTest03(){ ​ timer = new Timer(); ​ timer.schedule(new TimerTaskTest03(), 1000, 2000); ​ } ​ ​ public static void main(String[] args) { ​ new TimerTest03(); ​ } } public class TimerTaskTest03 extends TimerTask{ ​ @Override ​ public void run() { ​ Date date = new Date(this.scheduledExecutionTime()); ​ System.out.println(“本次执行该线程的时间为：” + date); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class TimerTest03 &#123; Timer timer; public TimerTest03()&#123; timer = new Timer(); timer.schedule(new TimerTaskTest03(), 1000, 2000); &#125; public static void main(String[] args) &#123; new TimerTest03(); &#125;&#125; public class TimerTaskTest03 extends TimerTask&#123; @Override public void run() &#123; Date date = new Date(this.scheduledExecutionTime()); System.out.println(&quot;本次执行该线程的时间为：&quot; + date); &#125;&#125; ​ 运行结果: [java] view plain copy 本次执行该线程的时间为：Tue Jun 10 21:19:47 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:49 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:51 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:53 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:55 CST 2014 本次执行该线程的时间为：Tue Jun 10 21:19:57 CST 2014 …………….. 12345678910111213141516171819202122232425本次执行该线程的时间为：Tue Jun 10 21:19:47 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:49 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:51 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:53 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:55 CST 2014本次执行该线程的时间为：Tue Jun 10 21:19:57 CST 2014................. ​ 对于这个线程任务,如果我们不将该任务停止,他会一直运行下去。 ​ 对于上面三个实例，LZ只是简单的演示了一下，同时也没有讲解scheduleAtFixedRate方法的例子，其实该方法与schedule方法一样！ 2.4、分析schedule和scheduleAtFixedRate​ 1、schedule(TimerTask task, Date time)、schedule(TimerTask task, long delay) ​ 对于这两个方法而言，如果指定的计划执行时间scheduledExecutionTime&lt;= systemCurrentTime，则task会被立即执行。scheduledExecutionTime不会因为某一个task的过度执行而改变。 ​ 2、schedule(TimerTask task, Date firstTime, long period)、schedule(TimerTask task, long delay, long period) ​ 这两个方法与上面两个就有点儿不同的，前面提过Timer的计时器任务会因为前一个任务执行时间较长而延时。在这两个方法中，每一次执行的task的计划时间会随着前一个task的实际时间而发生改变，也就是scheduledExecutionTime(n+1)=realExecutionTime(n)+periodTime。也就是说如果第n个task由于某种情况导致这次的执行时间过程，最后导致systemCurrentTime&gt;= scheduledExecutionTime(n+1)，这是第n+1个task并不会因为到时了而执行，他会等待第n个task执行完之后再执行，那么这样势必会导致n+2个的执行实现scheduledExecutionTime放生改变即scheduledExecutionTime(n+2) = realExecutionTime(n+1)+periodTime。所以这两个方法更加注重保存间隔时间的稳定。 ​ 3、scheduleAtFixedRate(TimerTask task, Date firstTime, long period)、scheduleAtFixedRate(TimerTask task, long delay, long period) ​ 在前面也提过scheduleAtFixedRate与schedule方法的侧重点不同，schedule方法侧重保存间隔时间的稳定，而scheduleAtFixedRate方法更加侧重于保持执行频率的稳定。为什么这么说，原因如下。在schedule方法中会因为前一个任务的延迟而导致其后面的定时任务延时，而scheduleAtFixedRate方法则不会，如果第n个task执行时间过长导致systemCurrentTime&gt;= scheduledExecutionTime(n+1)，则不会做任何等待他会立即执行第n+1个task，所以scheduleAtFixedRate方法执行时间的计算方法不同于schedule，而是scheduledExecutionTime(n)=firstExecuteTime +n*periodTime，该计算方法永远保持不变。所以scheduleAtFixedRate更加侧重于保持执行频率的稳定。 三、Timer的缺陷3.1、Timer的缺陷​ Timer计时器可以定时（指定时间执行任务）、延迟（延迟5秒执行任务）、周期性地执行任务（每隔个1秒执行任务），但是，Timer存在一些缺陷。首先Timer对调度的支持是基于绝对时间的，而不是相对时间，所以它对系统时间的改变非常敏感。其次Timer线程是不会捕获异常的，如果TimerTask抛出的了未检查异常则会导致Timer线程终止，同时Timer也不会重新恢复线程的执行，他会错误的认为整个Timer线程都会取消。同时，已经被安排单尚未执行的TimerTask也不会再执行了，新的任务也不能被调度。故如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。 ​ 1、Timer管理时间延迟缺陷 ​ 前面Timer在执行定时任务时只会创建一个线程任务，如果存在多个线程，若其中某个线程因为某种原因而导致线程任务执行时间过长，超过了两个任务的间隔时间，会发生一些缺陷： [java] view plain copy public class TimerTest04 { ​ private Timer timer; ​ public long start; ​ ​ public TimerTest04(){ ​ this.timer = new Timer(); ​ start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ System.out.println(“timerOne invoked ,the time:” + (System.currentTimeMillis() - start)); ​ try { ​ Thread.sleep(4000); //线程休眠3000 ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } ​ }, 1000); ​ } ​ ​ public void timerTwo(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ System.out.println(“timerOne invoked ,the time:” + (System.currentTimeMillis() - start)); ​ } ​ }, 3000); ​ } ​ ​ public static void main(String[] args) throws Exception { ​ TimerTest04 test = new TimerTest04(); ​ ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class TimerTest04 &#123; private Timer timer; public long start; public TimerTest04()&#123; this.timer = new Timer(); start = System.currentTimeMillis(); &#125; public void timerOne()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;timerOne invoked ,the time:&quot; + (System.currentTimeMillis() - start)); try &#123; Thread.sleep(4000); //线程休眠3000 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 1000); &#125; public void timerTwo()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;timerOne invoked ,the time:&quot; + (System.currentTimeMillis() - start)); &#125; &#125;, 3000); &#125; public static void main(String[] args) throws Exception &#123; TimerTest04 test = new TimerTest04(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 按照我们正常思路，timerTwo应该是在3s后执行，其结果应该是： [java] view plain copy timerOne invoked ,the time:1001 timerOne invoked ,the time:3001 12345timerOne invoked ,the time:1001timerOne invoked ,the time:3001 ​ 但是事与愿违，timerOne由于sleep(4000)，休眠了4S，同时Timer内部是一个线程，导致timeOne所需的时间超过了间隔时间，结果： [java] view plain copy timerOne invoked ,the time:1000 timerOne invoked ,the time:5000 12345timerOne invoked ,the time:1000timerOne invoked ,the time:5000 ​ 2、Timer抛出异常缺陷 ​ 如果TimerTask抛出RuntimeException，Timer会终止所有任务的运行。如下： [html] view plain copy public class TimerTest04 { ​ private Timer timer; ​ ​ public TimerTest04(){ ​ this.timer = new Timer(); ​ } ​ ​ public void timerOne(){ ​ timer.schedule(new TimerTask() { ​ public void run() { ​ throw new RuntimeException(); ​ } ​ }, 1000); ​ } ​ ​ public void timerTwo(){ ​ timer.schedule(new TimerTask() { ​ ​ public void run() { ​ System.out.println(“我会不会执行呢？？”); ​ } ​ }, 1000); ​ } ​ ​ public static void main(String[] args) { ​ TimerTest04 test = new TimerTest04(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class TimerTest04 &#123; private Timer timer; public TimerTest04()&#123; this.timer = new Timer(); &#125; public void timerOne()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; throw new RuntimeException(); &#125; &#125;, 1000); &#125; public void timerTwo()&#123; timer.schedule(new TimerTask() &#123; public void run() &#123; System.out.println(&quot;我会不会执行呢？？&quot;); &#125; &#125;, 1000); &#125; public static void main(String[] args) &#123; TimerTest04 test = new TimerTest04(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果：timerOne抛出异常，导致timerTwo任务终止。 [java] view plain copy Exception in thread “Timer-0” java.lang.RuntimeException ​ at com.chenssy.timer.TimerTest04$1.run(TimerTest04.java:25) ​ at java.util.TimerThread.mainLoop(Timer.java:555) ​ at java.util.TimerThread.run(Timer.java:505) 12345678910111213Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException at com.chenssy.timer.TimerTest04$1.run(TimerTest04.java:25) at java.util.TimerThread.mainLoop(Timer.java:555) at java.util.TimerThread.run(Timer.java:505) ​ 对于Timer的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。Timer是基于绝对时间的，对系统时间比较敏感，而ScheduledThreadPoolExecutor 则是基于相对时间；Timer是内部是单一线程，而ScheduledThreadPoolExecutor内部是个线程池，所以可以支持多个任务并发执行。 3.2、用ScheduledExecutorService替代Timer​ 1、解决问题一： [java] view plain copy public class ScheduledExecutorTest { ​ private ScheduledExecutorService scheduExec; ​ ​ public long start; ​ ​ ScheduledExecutorTest(){ ​ this.scheduExec = Executors.newScheduledThreadPool(2); ​ this.start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ System.out.println(“timerOne,the time:” + (System.currentTimeMillis() - start)); ​ try { ​ Thread.sleep(4000); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ } ​ },1000,TimeUnit.MILLISECONDS); ​ } ​ ​ public void timerTwo(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ System.out.println(“timerTwo,the time:” + (System.currentTimeMillis() - start)); ​ } ​ },2000,TimeUnit.MILLISECONDS); ​ } ​ ​ public static void main(String[] args) { ​ ScheduledExecutorTest test = new ScheduledExecutorTest(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class ScheduledExecutorTest &#123; private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest()&#123; this.scheduExec = Executors.newScheduledThreadPool(2); this.start = System.currentTimeMillis(); &#125; public void timerOne()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerOne,the time:&quot; + (System.currentTimeMillis() - start)); try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,1000,TimeUnit.MILLISECONDS); &#125; public void timerTwo()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerTwo,the time:&quot; + (System.currentTimeMillis() - start)); &#125; &#125;,2000,TimeUnit.MILLISECONDS); &#125; public static void main(String[] args) &#123; ScheduledExecutorTest test = new ScheduledExecutorTest(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果： [java] view plain copy timerOne,the time:1003 timerTwo,the time:2005 12345timerOne,the time:1003timerTwo,the time:2005 ​ 2、解决问题二 ​ [java] view plain copy public class ScheduledExecutorTest { ​ private ScheduledExecutorService scheduExec; ​ ​ public long start; ​ ​ ScheduledExecutorTest(){ ​ this.scheduExec = Executors.newScheduledThreadPool(2); ​ this.start = System.currentTimeMillis(); ​ } ​ ​ public void timerOne(){ ​ scheduExec.schedule(new Runnable() { ​ public void run() { ​ throw new RuntimeException(); ​ } ​ },1000,TimeUnit.MILLISECONDS); ​ } ​ ​ public void timerTwo(){ ​ scheduExec.scheduleAtFixedRate(new Runnable() { ​ public void run() { ​ System.out.println(“timerTwo invoked …..”); ​ } ​ },2000,500,TimeUnit.MILLISECONDS); ​ } ​ ​ public static void main(String[] args) { ​ ScheduledExecutorTest test = new ScheduledExecutorTest(); ​ test.timerOne(); ​ test.timerTwo(); ​ } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class ScheduledExecutorTest &#123; private ScheduledExecutorService scheduExec; public long start; ScheduledExecutorTest()&#123; this.scheduExec = Executors.newScheduledThreadPool(2); this.start = System.currentTimeMillis(); &#125; public void timerOne()&#123; scheduExec.schedule(new Runnable() &#123; public void run() &#123; throw new RuntimeException(); &#125; &#125;,1000,TimeUnit.MILLISECONDS); &#125; public void timerTwo()&#123; scheduExec.scheduleAtFixedRate(new Runnable() &#123; public void run() &#123; System.out.println(&quot;timerTwo invoked .....&quot;); &#125; &#125;,2000,500,TimeUnit.MILLISECONDS); &#125; public static void main(String[] args) &#123; ScheduledExecutorTest test = new ScheduledExecutorTest(); test.timerOne(); test.timerTwo(); &#125;&#125; ​ 运行结果： [java] view plain copy timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. timerTwo invoked ….. …………………… 12345678910111213141516171819202122232425262728293031323334353637timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .....timerTwo invoked .............................","categories":[],"tags":[]}]}